<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Domain Driven Design Glossary</title>
    <url>/2023/06/27/Domain%20Driven%20Design%20Glossary/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>领域驱动设计（Domain-Driven Design，简称DDD）是一种软件开发方法论，它强调通过深入理解领域知识和业务需求，将领域模型贯穿于整个软件开发过程中。</p>
<p>以下是一些领域驱动设计中常见的专业术语及其解释：</p>
<p>战略和战术设计是站在DDD的角度进行划分。</p>
<ul>
<li><p>战略设计侧重于高层次、宏观上去划分和集成限界上下文，而战术设计则关注更具体使用建模工具来细化上下文。</p>
</li>
<li><p>战略设计的目标是建立一个一致、有界和可演化的领域模型，帮助团队理解业务需求，并为战术设计提供指导。</p>
</li>
<li><p>战术设计的目标是在特定的限界上下文中构建合理、可维护的领域模型，通过建立领域对象之间的关系和定义明确的职责，实现业务逻辑的有效组织和封装。</p>
</li>
<li><p>战略设计：战略设计关注的是整个领域的全局性问题，以及如何将业务需求、领域知识和软件设计相结合。</p>
<ul>
<li><p>通用语言：在领域驱动设计中，通用语言是指开发团队和领域专家之间共享的、统一的业务语言。</p>
<p>通用语言在整个领域驱动设计过程中起着至关重要的作用。通过与领域专家密切合作，开发团队能够理解业务领域的专业术语、业务规则和概念。然后，开发团队将这些领域专有的语言转化为代码中的类、方法和属性等编程语言的元素。</p>
<p>通用语言的使用有助于消除开发人员和领域专家之间的沟通障碍，确保开发人员对领域需求的准确理解。它还促进了领域模型的一致性，使得领域模型能够贯穿于整个软件开发过程中，从需求分析到代码实现。</p>
<p>通用语言应该在限界上下文中得到充分运用，以确保在不同团队和组织之间的沟通和协作时能够保持一致。通过在代码中使用与通用语言相匹配的命名和概念，可以提高代码的可读性和可维护性，并增强团队之间的合作效率。</p>
</li>
<li><p>限界上下文（Bounded Context）：定义了业务领域的边界，并明确了在该上下文中使用的术语和概念。限界上下文帮助将大型领域划分为更小的、可管理的部分。</p>
</li>
<li><p>大胆的领域模型（Big Picture Model）：通过深入理解业务领域，建立起高层次、综合性的领域模型。这个模型用于指导整个软件系统的设计和演化。</p>
</li>
<li><p>上下文映射（Context Mapping）：指不同限界上下文之间的关系和交互方式。通过上下文映射，可以定义不同上下文之间的协作机制、数据交换方式等。</p>
</li>
<li><p>领域（Domain）：指特定业务领域或问题领域，是软件系统所涉及的核心概念和规则的集合。</p>
<ul>
<li><p>核心域（Core Domain）：核心域是指与业务的核心竞争力直接相关的部分。它包含了组织的关键业务流程、核心概念和业务规则。核心域通常是系统的重点关注区域，其中的领域模型和业务逻辑是复杂且变化频繁的。</p>
<p>对核心域的设计和开发需要投入更多的精力和资源，以确保系统在这个领域具有竞争优势。通常会采用更深入的领域建模和领域驱动设计技术，以满足核心业务需求。</p>
</li>
<li><p>支撑域（Supporting Domain）：支撑域是指与核心域紧密相关，但不直接构成核心业务的领域部分。它为核心域提供支持和辅助功能，帮助核心业务的实现和运行。</p>
<p>支撑域的特点是对业务的理解和变动要求较低，通常包括通用的基础设施、共享服务、安全性和认证等功能。支撑域的设计和开发可以借鉴成熟的技术和框架，以提高效率和稳定性。</p>
<p>通用域（Generic Domain）：通用域是指与特定业务领域无关的通用功能和共享资源。它包括通用的业务功能、通用工具和通用库等。通用域通常是广泛应用于多个领域的通用概念和模式。</p>
<p>通用域的设计和开发具有一定的通用性和重复性，可以通过复用现有的解决方案和组件来加快开发进度。通用域的设计应该具备可扩展性和灵活性，以满足不同领域的需求。</p>
</li>
<li><p>划分领域为核心域、支撑域和通用域有助于团队在系统架构和设计时有针对性地分配资源和关注点。核心域是系统的关键，需要更多的精力进行设计和演化；支撑域提供支持，减轻核心域的压力；而通用域提供了通用功能，可以在不同领域中复用。</p>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>战术建模：战术设计关注的是在限界上下文内部对领域模型进行具体的建模和设计。</p>
<ul>
<li>领域层(Domain Layer)：在分层架构中负责领域逻辑的那部分设计和实现。领域层是在软件中用来表示领域模型的地方。</li>
<li>领域模型（Domain Model）：是对领域的概念、行为和规则的抽象表示。它反映了领域的本质，并与业务专家的语言相对应。</li>
<li>实体（Entity）：是具有唯一标识的领域对象，具有生命周期和状态变化。实体通常与业务中的具体事物相对应，如订单、用户等。</li>
<li>值对象（Value Object）：是没有唯一标识的领域对象，其价值是由其属性的组合决定的。值对象通常用于描述不可变的概念，如日期、时间、货币等。</li>
<li>聚合（Aggregate）：是一组相关对象的集合，其中一个对象是聚合根（Aggregate Root）。聚合根负责维护整个聚合的一致性和边界。</li>
<li>聚合根（Aggregate Root）：是聚合中的一个对象，其他对象通过聚合根进行访问和操作。聚合根具有全局唯一的标识，并负责保证聚合的完整性。</li>
<li>领域事件（Domain Event）：表示领域中发生的重要事情或状态改变的事件。领域事件可以用于解耦领域模型之间的交互，同时支持事件驱动架构。</li>
<li>领域服务（Domain Service）：是一种无状态的操作，提供对领域中的特定行为或业务规则的操作。领域服务通常不持有状态，但可以操作领域对象。</li>
<li>模块Model：一个抽象的系统，描述了领域的所选方面，可用于解决与该领域有关的问题。在领域驱动设计中，模块（Module）通常是基于业务功能或子领域来定义的。它可以包含一组聚合、实体、值对象、领域服务以及处理领域事件等。模块的目的是将相关的领域概念和行为封装在一起，提供高内聚、低耦合的设计。模块有助于组织和管理复杂的领域模型，使其更易于理解和维护。每个模块可以有自己的限界上下文、领域专家和开发团队，使其能够独立地开发、测试和演化。</li>
</ul>
</li>
</ul>
<p>领域驱动设计的四个层次（Layered Architecture）：包括用户界面层（User Interface Layer）、应用层（Application Layer）、领域层（Domain Layer）和基础设施层（Infrastructure Layer）。每个层次有不同的职责和关注点，</p>
<ul>
<li><p>分析模式（Analysis Patterns）：分析模式（Analysis Patterns）是在领域驱动设计中使用的一种方法，用于识别和描述在特定领域中常见的模式和概念。这些模式和概念反映了领域内的通用问题和解决方案，并帮助开发团队更好地理解领域需求。</p>
<p>分析模式主要用于分析和理解领域，而不是直接用于具体的实现。它们通过描述领域中的重要概念、关系和行为，帮助开发团队和领域专家之间建立共享的语言和理解。</p>
<p>以下是一些常见的分析模式：</p>
<ol>
<li>实体（Entity）：表示在领域中具有唯一标识的对象。实体具有自己的属性和行为，并与其他实体之间存在关系。</li>
<li>值对象（Value Object）：表示在领域中具有特定属性但无需唯一标识的对象。值对象通常用于描述领域中的特定值或概念。</li>
<li>聚合（Aggregate）：表示一组相关对象的集合，由一个聚合根（Aggregate Root）负责维护整个聚合的一致性和边界。</li>
<li>仓储（Repository）：表示对领域对象进行持久化和检索的机制。仓储提供了一种访问领域对象的接口，隐藏了底层的数据访问细节。</li>
<li>服务（Service）：表示领域中的操作和行为，这些操作不属于特定的实体或值对象，而是跨越多个对象的逻辑操作。</li>
<li>事件（Event）：表示领域中发生的重要事情或状态改变。事件可以被用于触发其他领域对象的行为或通知其他上下文。</li>
<li>规则（Rules）：表示领域中的业务规则和约束。规则定义了领域对象的行为和限制条件。</li>
</ol>
<p>分析模式帮助开发团队通过共享的领域语言和模式，更好地理解和解决特定领域中的问题。它们可以作为设计的参考和指导，帮助构建更符合业务需求的领域模型和软件系统。</p>
</li>
<li><p>深层模型(Deep Model)：深层模型通常是指对领域进行更加细致和全面的建模，包括考虑业务的各种细节、规则和约束，以及满足领域的复杂需求。它通常与大规模、复杂的领域相关，需要深入理解和处理领域中的各种关系和交互。</p>
</li>
</ul>
<p>  深层模型的设计和实现需要结合领域专家的经验和领域知识，以及领域驱动设计中的建模技巧和方法。通过建立深层模型，可以更好地满足业务需求，提高系统的可靠性和灵活性。</p>
<p>资源拓展：</p>
<ol>
<li><a href="https://domainstorytelling.org/">Domain Storytelling - Domain Storytelling</a></li>
<li><a href="https://github.com/amerina/awesome-ddd">Awesome-DDD</a></li>
</ol>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Find Your Life Goals</title>
    <url>/2023/06/28/Find%20Your%20Life%20Goals/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="《成为你自己》"><a href="#《成为你自己》" class="headerlink" title="《成为你自己》"></a>《成为你自己》</h1><p><img src="https://i.postimg.cc/rs2HtrrG/20220607211453924.png" alt="目标层次结构"></p>
<p>拓展必看：</p>
<ul>
<li><a href="https://github.com/amerina/Beyourself/blob/main/BecomeYourSelf.md">成为你自己详解版</a></li>
<li><a href="https://github.com/amerina/Beyourself/blob/main/%E4%BA%BA%E7%94%9F%E7%90%86%E6%83%B3%E4%B8%8E%E7%9B%AE%E6%A0%87.xmind">人生理想与目标思维导图</a></li>
</ul>
<h2 id="1、为什么人生目标很重要"><a href="#1、为什么人生目标很重要" class="headerlink" title="1、为什么人生目标很重要?"></a>1、为什么人生目标很重要?</h2><p>书写格式正确的书面目标为什么如此重要</p>
<ul>
<li><p>决策疲劳</p>
<p><mark>我们是人。我们被编程为采取简单的选择。走阻力最小的路。只有我们清晰地知道自己想要什么，才有动力选择更难走的路。</mark><br><mark>如果你的目标明确，决策疲劳就会减少，你的选择也会变得更容易。</mark>更容易而不是容易:(</p>
</li>
<li><p>衡量(进度)&#x2F;动机</p>
<p>衡量你的进步和你花在目标上的时间，是不断提醒你对自己做出的承诺</p>
</li>
</ul>
<h2 id="2、人生目标的类型"><a href="#2、人生目标的类型" class="headerlink" title="2、人生目标的类型"></a>2、人生目标的类型</h2><p>请记住，是你选择了什么，而不是你没有选择的东西，让你在生活中快乐。</p>
<h3 id="目标类型分类"><a href="#目标类型分类" class="headerlink" title="目标类型分类"></a>目标类型分类</h3><ul>
<li>成果目标：做出实实在在的成果</li>
<li>过程目标：每天专注完成的任务习惯</li>
<li>性能目标：个人标准</li>
<li>主题目标：专注于某个领域的目标</li>
<li>时间目标：有DeadLine的目标</li>
</ul>
<h3 id="人生目标分类"><a href="#人生目标分类" class="headerlink" title="人生目标分类"></a>人生目标分类</h3><ul>
<li>健康目标：每周固定的练习时间</li>
<li>财务目标：获得一个稳定&#x2F;舒适的财务状况</li>
<li>关系目标：维系家庭和朋友关系可能是最简单的方法，以戏剧性地改善你的生活和你的整体幸福感。</li>
<li>教育目标：终身学习者的心态</li>
<li>个人发展目标：成为更优秀的你</li>
<li>职业目标：确定一个明确的职业目标</li>
<li>心理目标：适当地放空自己，有规律地休息或活动给自己减压</li>
<li>生活方式目标：休闲目标、爱好&#x2F;朋友很重要</li>
<li>退休目标：仔细想想你的退休目标是什么</li>
</ul>
<h2 id="3、如何设定目标"><a href="#3、如何设定目标" class="headerlink" title="3、如何设定目标"></a>3、如何设定目标</h2><p>不管你使用什么技巧，记住，如果目标没有写下来，你就没有目标。同时，记住要为你的目标设定激励。<strong>如果你的目标不能激发行动，那么它们对你就没有用处。</strong></p>
<h3 id="目标设定方法-技术-框架"><a href="#目标设定方法-技术-框架" class="headerlink" title="目标设定方法&#x2F;技术&#x2F;框架"></a>目标设定方法&#x2F;技术&#x2F;框架</h3><ul>
<li><p><strong>每个类别一个目标技巧</strong></p>
<p>浏览第二章的分类列表，绞尽脑汁，直到你能为每个分类想出一个目标。</p>
</li>
<li><p><strong>价值观优先技巧</strong></p>
<p>一旦你有了这个列表，你就有了一个透镜来审视你的生活。你可以问问自己，那些看重 x 的人会做什么？他们如何与人交流？</p>
</li>
<li><p><strong>目的第一技巧</strong></p>
<p>如果你已经知道你的人生目标是什么，那么通过目标的透镜来审视你生活的方方面面，设定有效的目标是极其容易的。</p>
</li>
<li><p><strong>Why，What，How技巧</strong></p>
<p>如果你还没有看过，你真的应该看看西蒙 · 西尼克的 TED 演讲，名为<strong>“从为什么开始”</strong>。</p>
<p><em>Notes：想象一下雇主为什么非要雇佣你不可，你有什么不可替代的吸引力</em></p>
</li>
<li><p><strong>SMART Goals 明智的目标</strong></p>
<ul>
<li>Specific 具体点</li>
<li>Measurable 可测量的</li>
<li>Attainable 可以实现</li>
<li>Relevant 相关的</li>
<li>Time-bound 有时限的</li>
</ul>
<p><strong>SMART 目标描述了一个完善的目标的剖析。</strong></p>
</li>
<li><p><strong>讣告技巧</strong></p>
<p>讣告方法给了你一个很好的方式去思考你想要什么样的目标，而不仅仅是如何写目标(比如 SMART 目标)。</p>
</li>
</ul>
<h2 id="4、生活目标的例子"><a href="#4、生活目标的例子" class="headerlink" title="4、生活目标的例子"></a>4、生活目标的例子</h2><ul>
<li><p>财务目标例子</p>
<p><strong>在未来5年内每年赚取 $x $000美元</strong></p>
</li>
<li><p>教育目标实例</p>
<ul>
<li><strong>我将每年至少做 x 个网络课程变成我的爱好。只有有趣的事情</strong></li>
<li><strong>在接下来的两年里，我将学习如何把 x 说成一个测试级别的 x</strong></li>
</ul>
</li>
<li><p>个人发展目标的例子</p>
<ul>
<li>我将致力于我的时间管理和承诺。我会更频繁地对新事物说不，以保证我能够兑现我已经许下的诺言</li>
<li>我会更认真地对待个人责任。我不会因为我对结果有部分影响的事件而责怪他人</li>
</ul>
</li>
<li><p>关系目标例子</p>
<p>我会每周至少联系我所有亲近的家人一次，看看他们过得怎么样</p>
</li>
<li><p>职业目标的例子</p>
<ul>
<li><strong>我将有勇气改变我的职业生涯。永远不会太迟。我现在将采取渐进的步骤，目标是在未来24个月内进入这个行业</strong></li>
<li>我将在未来3年内开始我自己的事业，在一个行业，我喜欢和发现迷人</li>
</ul>
</li>
<li><p>心理目标的例子</p>
<p><strong>我会每天冥想10分钟，写日记，这样我总是能够自我意识到是什么导致了我内心的挣扎和痛苦</strong></p>
</li>
<li><p>生活方式目标的例子</p>
<ul>
<li>成为比我年轻的人的榜样，在那里指导他们，帮助他们成长</li>
<li><strong>我将在未来5年内自行出版一本书。如果我能让100个人读我的作品，我会很高兴，也会很满足</strong></li>
</ul>
</li>
</ul>
<h2 id="5、人生目标语录"><a href="#5、人生目标语录" class="headerlink" title="5、人生目标语录"></a>5、人生目标语录</h2><ul>
<li><strong>一个正确设定的目标已经实现了一半</strong></li>
<li><strong>设定目标是将无形变为有形的第一步</strong></li>
<li><strong>在没有明确目标的情况下，我们会变得奇怪地忠于每天做一些琐碎的事情</strong></li>
<li><strong>一个目标并不总是意味着要达到，它通常只是告诉我们目的地</strong></li>
<li><strong>当目标明显无法实现时，不要调整目标，调整行动步骤</strong></li>
<li><strong>目标是一个有最后期限的梦想</strong></li>
<li><strong>目标是强大的动力，但它们也会让你痛苦。你需要一流的日常习惯</strong></li>
</ul>
<p>最后一句话很好地开启了下一章。在这篇文章中，我们将讨论长期坚持目标的策略，以及如何让自己对自己负责。</p>
<h2 id="6、如何坚持你的目标"><a href="#6、如何坚持你的目标" class="headerlink" title="6、如何坚持你的目标"></a>6、如何坚持你的目标</h2><ul>
<li><p>每周&#x2F;每月&#x2F;每季度和每年的回顾</p>
<p>星期天是我的复习日。我重新阅读了我所有的目标，以及当我决定这些目标对我很重要的时候，我所写的关于它们的内容。</p>
<p>如果没有这种有规律的强化，你的目标就会半途而废。你需要评估你的进展，并决定在接下来的一周里需要做些什么。</p>
<p>我知道这一切听起来像“工作”。没错。它应该是。自尊和实现你的目标是工作。</p>
<p><strong>你不会后悔每周花15分钟来反思你人生中最重要的愿望。</strong></p>
</li>
<li><p>我应该有多少个目标？</p>
<p>应该在3到5之间。你需要能够记住它们，并把它们放在首位。</p>
</li>
<li><p><strong>里程碑的力量</strong></p>
<p>里程碑可以被认为是子目标，但它们可以更容易地使用 SMART 目标格式编写。</p>
</li>
<li><p><strong>奖励自己的进步</strong></p>
<p>如果你真的达到了一个里程碑，庆祝吧！这是一个了不起的成就，你立即进入前5% 的人。</p>
</li>
<li><p>实现人生目标</p>
</li>
</ul>
<h2 id="7、使用讣告技巧确定人生目标"><a href="#7、使用讣告技巧确定人生目标" class="headerlink" title="7、使用讣告技巧确定人生目标"></a>7、使用讣告技巧确定人生目标</h2><ol>
<li><p>描述你想成为什么样的人。用你的讣告作为框架来表达你自己。</p>
<p>发现你的人生目的和目标，你要做的第一件事就是写你的讣告。</p>
</li>
<li><p>为生活的不同方面创建四个人生目标</p>
</li>
<li><p>对于每个目标，你都要思考你想要它的原因</p>
<p>如果你实现了这个目标，它将如何影响你的生活？</p>
</li>
<li><p>思考如果目标失败了的话你的生活是怎样的？</p>
<p>你对自己的情绪和失败的感觉越清楚，你成功的动力就越强大。</p>
</li>
<li><p>从今天开始的十二个月内，你将设定一个S.M.A.R.T. 里程碑，它将成为你实现目标的垫脚石。</p>
<p>你需要设定一个时间点，在这个时间点上你可以检查你的进度，从而鼓励你今天就采取行动。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Goal</category>
      </categories>
      <tags>
        <tag>Goal</tag>
      </tags>
  </entry>
  <entry>
    <title>Macola Domain Knowledge</title>
    <url>/2023/11/20/Macola%20Domain%20Knowledge/</url>
    <content><![CDATA[<h3 id="Key-Words"><a href="#Key-Words" class="headerlink" title="Key Words"></a>Key Words</h3><table>
<thead>
<tr>
<th>AP–Accounts Payable</th>
<th>应付账款</th>
</tr>
</thead>
<tbody><tr>
<td>AR–Accounts receivable</td>
<td>应收账款</td>
</tr>
<tr>
<td>BB-Bank account book</td>
<td>银行账簿</td>
</tr>
<tr>
<td>GL-General ledger management</td>
<td>总账管理</td>
</tr>
<tr>
<td>IM-Inventory management</td>
<td>库存管理</td>
</tr>
<tr>
<td>OE-Order management</td>
<td>订单管理</td>
</tr>
<tr>
<td>PO-purchase order</td>
<td>采购订单</td>
</tr>
<tr>
<td>SM-System Management</td>
<td>系统管理</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Credit-Memo-And-Debit-Memo"><a href="#Credit-Memo-And-Debit-Memo" class="headerlink" title="Credit Memo And Debit Memo"></a>Credit Memo And Debit Memo</h3><p>在 Macola ERP 中，Credit Memo（贷项通知单）和 Debit Memo（借项通知单）是两种常见的会计术语，用于记录销售和采购交易中的调整。</p>
<p>Credit Memo（贷项通知单）通常用于以下情况：</p>
<ol>
<li>退货：当客户退回已购买的产品时，您可以发出贷项通知单来退还客户的付款。</li>
<li>价格调整：如果您需要调整产品的销售价格，您可以发出贷项通知单来减少客户的应付款项。</li>
<li>优惠折扣：如果您给客户提供了折扣或优惠，您可以发出贷项通知单来减少客户的应付款项。</li>
</ol>
<p>Debit Memo（借项通知单）通常用于以下情况：</p>
<ol>
<li>补发货物：当您漏发了产品或提供了不完整的订单时，您可以发出借项通知单来增加客户的应付款项。</li>
<li>价格调整：如果您需要调整产品的采购价格，您可以发出借项通知单来增加供应商的应付款项。</li>
<li>罚款或违约金：如果供应商或客户未履行合同条款，您可以发出借项通知单来增加对方的应付款项。</li>
</ol>
<p>总结起来，<strong>Credit Memo（贷项通知单）用于减少客户的应付款项，而 Debit Memo（借项通知单）用于增加客户或供应商的应付款项。</strong>这些通知单可以帮助您记录交易的调整和变更，确保账目的准确性。</p>
<h3 id="Accounts-Receivable-And-Accounts-Payable"><a href="#Accounts-Receivable-And-Accounts-Payable" class="headerlink" title="Accounts Receivable And Accounts Payable"></a>Accounts Receivable And Accounts Payable</h3><p>在 Macola ERP 中，AR 和 AP 是会计术语，分别代表应收账款（Accounts Receivable）和应付账款（Accounts Payable）。</p>
<p>AR（应收账款）是指企业向客户销售商品或提供服务后尚未收到的付款金额。当您向客户发出销售发票时，相应的金额会记录在应收账款中。AR 反映了客户欠您的款项，是您从客户那里应收的资金。</p>
<p>AP（应付账款）是指企业购买商品或接受服务后尚未支付的金额。当您从供应商收到采购发票时，相应的金额会记录在应付账款中。AP 反映了您欠供应商的款项，是您应付给供应商的资金。</p>
<p>AR 和 AP 是财务管理中重要的指标，可以帮助企业跟踪和管理与客户和供应商之间的财务关系。通过监控 AR 和 AP 的变化，您可以了解企业的应收款项和应付款项的状况，并及时采取措施来确保资金流动的正常运作。</p>
<h3 id="Accounts-Payable"><a href="#Accounts-Payable" class="headerlink" title="Accounts Payable"></a>Accounts Payable</h3><h3 id="BB-Bank-account-book"><a href="#BB-Bank-account-book" class="headerlink" title="BB-Bank account book"></a>BB-Bank account book</h3><p> “Bank Account Book”，即银行账户簿。银行账户簿是记录企业或个人在银行中的账户活动的记录。它包含了存款、取款、利息、手续费等与银行账户相关的交易信息。</p>
<p>在 Macola ERP 中，您可以使用银行账户簿来跟踪和管理与银行账户相关的财务活动。这包括记录存款、提现、支票、银行费用等。通过维护准确的银行账户簿，您可以确保与银行账户的余额和交易记录一致，并进行有效的现金管理和对账操作。</p>
<h3 id="GL-Account、Cost-Unit、Cost-Center"><a href="#GL-Account、Cost-Unit、Cost-Center" class="headerlink" title="GL Account、Cost Unit、Cost Center"></a>GL Account、Cost Unit、Cost Center</h3><p>在 Macola ERP 中，”GL Account” 是指 “General Ledger Account”，即总账科目。总账科目是用于记录和跟踪企业财务交易的分类账户。它们用于汇总和组织财务信息，以便进行报表编制、财务分析和决策制定。</p>
<p>总账科目可以代表不同类型的资产、负债、所有权权益、收入和费用。每个总账科目都有一个唯一的编码和名称，用于识别和区分不同的科目。例如，现金、应收账款、应付账款、销售收入、采购成本等都可以是总账科目。</p>
<p>另外，”Cost Unit” 和 “Cost Center” 是与成本管理相关的概念。”Cost Unit” 是指成本单位，它可以是产品、项目、部门或其他任何可以衡量成本的实体。”Cost Center” 是指成本中心，它是一个特定部门、团队或业务单位，负责管理和控制相关成本。</p>
<p>在 Macola ERP 中，您可以使用总账科目、成本单位和成本中心来跟踪和管理企业的财务和成本信息。这些概念相互关联，帮助您进行准确的财务报告、成本分析和预算控制。</p>
<h3 id="Closing-of-account-period"><a href="#Closing-of-account-period" class="headerlink" title="Closing of account period"></a>Closing of account period</h3><p>在 Macola ERP 中，”账期关闭”是指在特定时间段结束后，对财务和会计模块中的账期进行结算和关闭的过程。账期关闭的目的是确保财务数据的准确性和完整性，以便进行财务报表的生成和分析。</p>
<p>账期关闭通常涉及以下步骤：</p>
<ol>
<li><p>结账准备：在进行账期关闭之前，需要进行一些准备工作。这包括确认所有财务交易都已正确记录和处理，检查余额和科目的准确性，处理未对账的项目，确保凭证和账户的一致性等。</p>
</li>
<li><p>结账操作：一旦准备工作完成，可以进行账期关闭操作。这通常由财务或会计人员在 Macola ERP 中执行。在进行账期关闭时，系统会自动进行一系列的处理，如计算余额、更新账期信息、生成结账报表等。</p>
</li>
<li><p>结账报表：账期关闭后，系统会生成一些结账报表，用于展示账期内的财务数据和统计信息。这些报表可以包括利润表、资产负债表、现金流量表等财务报表，以及其他统计报表和分析工具。</p>
</li>
<li><p>锁定账期：一旦账期关闭和报表生成完成，通常会对该账期进行锁定，防止后续的修改或录入操作对已结账期的数据产生影响。这可以确保账期的数据不会被意外更改，保持数据的完整性和可追溯性。</p>
</li>
</ol>
<p>通过账期关闭的操作，企业可以确保财务数据的准确性和一致性，为管理层和利益相关者提供可靠的财务信息，并支持决策和报告的准备工作。这是财务和会计管理中的重要步骤，有助于维护财务数据的可靠性和可信度。</p>
]]></content>
      <categories>
        <category>Macola ERP</category>
      </categories>
      <tags>
        <tag>Macola ERP</tag>
      </tags>
  </entry>
  <entry>
    <title>Make Your Time Valuable</title>
    <url>/2023/11/28/Make%20Your%20Time%20Valuable/</url>
    <content><![CDATA[<ul>
<li>你是否经常感觉自己有很多想做的事情，但总是拖延着难以开始？</li>
<li>你是否明知道接下来有重要的事，但依旧刷视频、玩手机，一边心里牵挂着要做的事，一边又心怀愧疚地继续娱乐？</li>
<li>你是否时常想要摆脱这种状态，制定一堆计划，却在第一天就败下阵来，然后开启长时间的颓废与迷茫？</li>
<li>你是否经常感到焦虑、迷茫，觉得自己一事无成？</li>
</ul>
<p>你是否想要改变？</p>
<p>学习时间管理关键是要有行动。我分享一下我个人系统提升自己的时间管理能力的方法。</p>
<ol>
<li>时间日志。坚持每天写时间日志，记录自己时间的花费情况，分析不足。</li>
<li>做好计划。小事要计划，大事要谋划。做每件事前都要进行思考，怎么行动，无计划不行动，有计划则认真执行。</li>
<li>明确目标。要学会把模糊的梦想变成清晰的目标，制订目标要考虑自己的行业和特长，同时也要考虑目标的连贯性，坚持坚持再坚持。</li>
<li>四象限法则。通过重要性和紧急性两个维护，把事情划分为重要且紧急、重要不紧急、紧急不重要、不紧急不重要四个类别，优先做重要不紧急的事情。</li>
<li>二八法则。运用二八法则（或者叫二八定律），把80%的时间用在重要的20%的事情上，以期产生80%的效果。</li>
<li>学会授权： 我们或多或少都遇过多得超出承受范围的任务， 并因此压力重重、精疲力竭。 委派任务并不是逃避责任，而是一种管理技巧。 根据下属各自的优势长处，你可以考虑把任务分派给他们。</li>
<li>懂得拒绝： 如果感到工作量太大，可以尝试委婉拒绝额外工作。 接受额外工作前先看下自己的任务清单吧。</li>
<li>杜绝拖延：拖延是严重影响效率的一大恶因，既浪费时间又耗费精力，无论如何都要杜绝，否则会极大危害你的工作和生活。</li>
</ol>
<h3 id="1、为什么要做时间管理？"><a href="#1、为什么要做时间管理？" class="headerlink" title="1、为什么要做时间管理？"></a>1、为什么要做时间管理？</h3><ul>
<li><p>规划人生方向，把控自己的生活</p>
<p>时间管理要求我们充分利用时间，为自己设定目标、制定计划，并根据计划付出行动、取得成功。</p>
<p>也就是说，我们对自己想要实现的人生有一定的方向感，而这个方向感正是解决我们迷茫的因素之一，它能帮助我们更好地把控生活，做到心中有数。</p>
</li>
<li><p>提高做事的效率</p>
<p>在没有进行时间管理的情况下，我们脑子里可能装有很多事情，在做一件事的时候心里常常会想着另外的事情，导致两件事都不能高效完成；</p>
<p>也有可能分不清事情的轻重缓急，造成不必要的麻烦。而时间管理，则可以帮助我们收集、整理并规划所有待办事项，培养我们的专注度，提高我们做事的效率。</p>
</li>
<li><p>为自己创造价值和更多的可能性</p>
<p>时间是很公平的，每个人一天都有 24 个小时，有的人可以充分利用这些时间，去学习成长，培养兴趣，或是旅游出行；<br>有的人一有空闲时间，只会看剧、游戏或者刷短视频。每个人都有各自不同的人生追求，我们无法去评判何种人生更加成功，但做好时间管理，至少可以让我们成为时间的主人，为自己创造更多价值和更多的可能</p>
</li>
</ul>
<h3 id="2、时间管理方法"><a href="#2、时间管理方法" class="headerlink" title="2、时间管理方法"></a>2、时间管理方法</h3><ol>
<li><p><a href="https://www.bilibili.com/video/BV1wE411176Q?p=1">GTD(Getting Things Done)-把事情做完</a></p>
<p>概念 GTD：List需要做的事情,集中精力在正在完成的事情上</p>
<p><strong>GTD 工作流程：</strong></p>
<p>GTD 分为收集、整理、组织、回顾、执行五个步骤。</p>
<ol>
<li>第一步，我们需要将自己脑海中想到的事情全部收集起来</li>
<li>第二步，将收集箱清空，将收集箱里面的事务分配到不同的板块：对于无法转化为行动的事情，如果没有用，则删除；如果将来也许会用到，可以放入自己的备忘录；如果可以作为资料参考，则放入自己的参考资料库。对于可以转化为行动的事情，如果两分钟内可以完成的话就立即去做；如果两分钟内不能完成的话，要么委派他人完成，要么延迟处理。延迟处理的事项中，有特定时间的放入日程中，其他的作为待办事项，但需要随时关注并不断指定时间去完成。左边的部分属于组织与回顾，我们需要定期进行总结；关注事项进度；以及为未完成的事项规划时间等。</li>
</ol>
<p><a href="https://mubu.com/doc/6vQJPom7iH6">GTD搞定-Getting Things Done</a></p>
</li>
<li><p><a href="https://share.mubu.com/doc/5kwb6KqXOX6">ZTD(Zen To Done )-轻松搞定</a></p>
<p>ZTD 是轻松搞定，Zen To Done 的简称，可以理解为简化版的 GTD，但两者的侧重点有所不同。</p>
<p><strong>ZTD 保持了 GTD 系统中收集信息和规划行动的方法，但更关注的是行动本身。</strong>怎么才能最大程度地简化计划系统呢？答案就是培养习惯，这也是 ZTD 的核心所在。</p>
<p><strong>ZTD工作流程：</strong></p>
<p>ZTD 完整的组成有十个习惯，分别是：收集、处理、计划、行动、建立简单可信的清单系统、整理、回顾、简化、设定习惯和找到热情。</p>
<ol>
<li>收集：随时记录的习惯</li>
<li>处理：要求快速决定收集箱中的事项，并从中找到重点</li>
<li>计划：指设定每天或每周要做的事</li>
<li>行动：专注执行计划</li>
<li>建立简单可信的清单系统：指的是要有归档思维，并形成正确可信的系统</li>
<li>整理：指保持整洁、使用标签，让你能迅速找到任何你想找到的东西</li>
<li>回顾：则是对目标的强化，同时关注你的任务、清单和收集箱</li>
<li>简化：是说要尽量减少你的任务清单，删除不必要的事项，并抽出时间集中处理待办</li>
<li>设定习惯：指的是对自己的任务进行梳理，找出一些规律性的、周期性的事务，形成习惯</li>
<li>找到热情：最后就是找到你热爱的东西，让你保持动力。</li>
</ol>
<p>ZTD 并不要求我们一次做到这十个习惯，ZTD 讲究循序渐进，每次养成一个习惯就好。<br>如果还是觉得麻烦，可以使用 ZTD 精简版，<strong>精简版的 ZTD 只包含四个习惯：收集、处理、计划和行动。</strong></p>
<p>事实上，完整版的 ZTD 的十个习惯可以看做是对这四个习惯的补充，因此可以选择先培养精简版里面的习惯，之后再根据自己的实际需求培养其他的六个习惯。</p>
</li>
<li><p>番茄工作法</p>
<p>番茄工作法是简单易行的时间管理方法，由弗朗西斯科·西里洛于 1992 年创立。使用番茄工作法需准备的工具有：一个番茄计时器，三张表格。</p>
<p><strong>使用番茄工作法需遵守的规则如下：</strong></p>
<ol>
<li>一个番茄时间共 30 分钟，25 分钟工作,5 分钟休息</li>
<li>一个番茄时间是不可分割的</li>
<li>每 4 个番茄时间后，停止工作，进行一次较长时间的休息，大约 15 到 30 分钟</li>
<li>完成一个任务就划掉一个。</li>
</ol>
<p><strong>番茄工作法的精髓在于：</strong></p>
<ol>
<li>一次只做一件事，保持专注；</li>
<li>按照轻重缓急程度分解目标任务，高效完成；</li>
<li>做完一件划掉一件，增加成就感，避免半途而废；</li>
<li>整理杂乱无序的工作事项，克服拖延症；</li>
<li>持续性改善时间管理能力，让优秀成为一种习惯。</li>
</ol>
<p>番茄工作法可以帮助我们轻松地提高自己的时间管理能力，让每一项任务的结果都能达到预期。</p>
<p><strong>番茄工作法流程：</strong></p>
<ol>
<li>设定日平均番茄数</li>
<li>活动清单：记录全部待办事项,为每个待办事项预估番茄钟个数</li>
<li>今日清单：从活动清单中挑选今日事项,不要超过设定的日平均番茄钟</li>
<li>番茄钟执行：25min工作+5min休息</li>
<li>长时休息：每四个番茄钟左右</li>
<li>记录分析番茄钟实际执行效果</li>
<li>记录改善建议</li>
</ol>
<p>我们首先需要给自己设定一个每天要完成的平均番茄钟数，每天早晨先整理并记录自己的活动清单，并为每一项任务预估一个所需要的的番茄钟个数，注意这里的活动清单包含全部的待办事项；</p>
<p>然后我们要从活动清单中挑选出今日的待办事项，放到今日清单中，为了保证自己能完成任务，我们今日清单中的待办事项所需番茄钟个数尽量不要超过自己设定的其平均番茄数；</p>
<p>接下来就是番茄钟执行了，在执行的过程中尽量保证不被打断，否则番茄钟作废，如果是计划之外的事情导致番茄钟中断，如果该事项需要立即执行，则记录中断原因，如果该事项不必立即执行，可以将其记录并添加到活动清单当中；</p>
<p>每四个番茄钟左右，需要进行一次长时休息，以保证良好的身体状态，休息之后则进行下一个番茄钟；</p>
<p>一天结束之前，记录并分析自己的番茄钟完成情况，并不断改善进步，提高番茄钟的预估准确度以及执行效率。这样番茄钟工作法就可以正向循环了。</p>
</li>
<li><p>时间统计法</p>
<p>时间统计法核心在于坚持记录并统计自己的时间成本，并定期做总结复盘</p>
<p>时间统计法要点：</p>
<p>柳比歇夫每天都会记录自己的时间开销，载体为日记本，每天按照“日期+事件+花费时间”的形式记录自己的时间，大约5-7行文字。</p>
<p>我们在记录时间的时候，应该注意一个要点：</p>
<ul>
<li><strong>我们应当有自己的目标，而不是单纯地记流水账，因为记录时间是为了让我们能够更好地掌控时间，从而实现自己的目标</strong></li>
</ul>
<p>另外值得注意的有：</p>
<ol>
<li>对工作任务分类记录时间，比如，记录自己用在写作方面的时间、学习提升的时间、科研活动的时间等</li>
<li>注重有效工作时间，同时要保证自己休息，一累则马上去休息</li>
<li>定期总结，实现对时间的精准分配，提高自己对时间的把控力。</li>
</ol>
</li>
<li><p>时间四象限法</p>
<p>时间四象限法是美国的管理学家科维提出的一个时间管理的理论，他把工作按照重要和紧急两个不同的程度进行了划分，基本上可以分为四个象限：</p>
<ul>
<li><p>紧急重要：重要紧急的事项要立即亲自去做</p>
<p>如客户投诉、即将到期的任务、财务危机等</p>
</li>
<li><p>重要不紧急：重要不紧急的事项需要专门抽出时间有计划地去做</p>
<p>如建立人际关系、人员培训、制订防范措施等</p>
</li>
<li><p>紧急不重要：紧急不重要的事项可以稍后做或者委派他人</p>
<p>如电话铃声、不速之客、部门会议等</p>
</li>
<li><p>不紧急不重要：不紧急不重要的事项则尽量不做</p>
<p>如上网、闲谈、邮件、写博客等。这种把工作按照重要和紧急两个不同的维度进行时间划分的时间管理方法就是时间四象限法。</p>
</li>
</ul>
<p>处理顺序：</p>
<p>时间四象限法推荐的事项处理顺序如下：先处理紧急重要的，接着是重要不紧急的，再到紧急不重要的，最后才是不紧急不重要的。</p>
<p>有的人认为时间四象限法不科学，争议点主要在于紧急不重要事项与重要不紧急事项之间的处理顺序上，他们认为虽然有些事不重要，但由于其紧急性也需要及时处理，如给猫购买猫粮；而重要不紧急的事情通常需要耗费很大的精力去完成，如学习 JAVA；倘若等到学完 JAVA 再购买猫粮，猫早就被饿死了。</p>
<p>但其实，时间四象限法可以为我们的时间管理提供正向的帮助，它提醒我们要警惕那些紧急不重要的事情，我们容易被这样的事项蒙蔽，导致整天都很忙碌，可却没有得到实际性的提升；它也提醒我们要重点关注那些重要不紧急的事项，这样的事项最容易被我们遗忘，但确是我们提升的最好路径，如学习剪辑课程；坚持写文章；理财等。</p>
</li>
<li><p>一万小时理论</p>
<ul>
<li><p>一万小时定律：要想将一门技能熟练掌握，需要做的就是反复刻意练习</p>
<p>一万小时定律是作家格拉德威尔在《异类》一书中指出的定律。<br>主要思想在于：人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。</p>
<p>马尔科姆·格拉德韦尔的《异类》与丹尼尔·科伊尔的《一万小时天才理论》，其核心都是“一万小时定律”，就是不管你做什么事情，只要坚持一万小时，基本上都可以成为该领域的专家。</p>
<p>与此相通的另一本书籍《刻意练习》，也是讲的这个道理：要想将一门技能熟练掌握，需要做的就是反复刻意练习，现实中基本没有什么天才可以不需要练习就取得成功。</p>
</li>
<li><p>理论核心：</p>
<p>而在我们的实际操作中，核心就在于为自己设定目标，即你想要熟练掌握的技能，然后利用空余时间去练习，并记录自己的学习或练习时长。</p>
<p>注意：不一定要设置为一万小时，对于一些小目标可以设定200或300小时，因为并不是所有技能你都想做到专家的状态，但是一旦你为这些目标设定了时间，你就会有一种方向感和从容感，知道自己的每一步都是在向着目标前进，自然就会有一种对时间的把控感。</p>
<ul>
<li>核心就在于为自己设定目标，即你想要熟练掌握的技能</li>
<li>利用空余时间去练习，并记录自己的学习或练习时长</li>
</ul>
</li>
</ul>
</li>
<li><p>三只青蛙法</p>
<ul>
<li><p>概念：核心是要事第一</p>
<p>三只青蛙的概念出自博恩·崔西的《吃掉那只青蛙》一书，博恩. 崔西是世界顶级销售培训大师，他为全球500多万名专业人士做过培训，就连比尔.盖茨、沃伦.巴菲特等世界级商业领袖都曾经接受过他的领导者管理思想培训。类似核心的书籍还有《要事第一》。</p>
<p>青蛙，指的是对你而言最重要、需要花费很多精力、乃至是最困难，但是做好之后能有很大收获的任务。</p>
<p>我们首先需要明确自己的目标，然后将目标化整为零，逐步拆分，并根据优先级将任务划分为ABCDE五个类别，并利用80&#x2F;20法则，<br>关注你的任务中那20%的能创造80%结果的任务，明确每年、每月、每周以及每天最重要的三个青蛙，然后优先去处理这些最具有挑战和难度的任务，并经常总结。</p>
<p>俗话说“万事开头难”，如果这些“青蛙”我们不优先完成的话，很容易造成我们的拖延症，或是让我们处于逃避状态，这也就是为什么应该“要事第一”。</p>
</li>
<li><p>青蛙，指的是对你而言最重要、需要花费很多精力、乃至是最困难，但是做好之后能有很大收获的任务</p>
</li>
<li><p>明确每年、每月、每周以及每天最重要的三个青蛙</p>
</li>
</ul>
</li>
<li><p>Don’t Break the Chain</p>
<p>Don’t Break the Chain，意思是说：“不要断链”，这个概念比较小众，但其内在核心在生活中的应用却非常多。</p>
<p>该概念出自Jerry Seinfeld的故事，为了创作好的笑话，这位滑稽演员给自己设定了每天都写笑话的规矩。 他买了个巨大的挂历，每天做了创作笑话的工作后就用红色记号笔在那一天的方框里画个大大的叉。 坚持一段时间后，日历上就会出现一条红色的链子，接下来要做的，就是“不要打断它”。</p>
<p>其实这就相当于习惯的养成，目前有很多习惯类打卡的APP就是基于这个理念，每次打完卡之后，日历上面都会有圆圈标记，这就会促使我们培养并坚持习惯，因为我们总是倾向于“不想让打卡中断”。</p>
</li>
</ol>
<h3 id="3、如何定制适合自己的时间管理系统"><a href="#3、如何定制适合自己的时间管理系统" class="headerlink" title="3、如何定制适合自己的时间管理系统"></a>3、如何定制适合自己的时间管理系统</h3><p>前面我们已经大致了解了一些主流的时间管理方法，</p>
<p>但方法不在于多，我们应该如何灵活地运用它们，并构建适合自己的时间管理系统呢？接下来我们将通过具体案例进行学习，从该章节开始，希望大家可以每节课都进行实践，一起来搭建自己的时间管理体系。</p>
<ol>
<li><p>了解并把控时间</p>
<p>我们要进行时间管理，那么首先要做的就是了解并把控时间。有人会问了：时间还需要了解吗？每个人不都是一天24个小时？</p>
<p>事实的确如此，但对于每一个不同的个体，我们可以利用的时间却是各不相同的，并且会随着我们人生的发展阶段不断地变化，因此，我们首先要明确自己在不同阶段的角色定位，并将自己可利用的时间进行分类。</p>
<ol>
<li><p>明确自己的角色与定位</p>
<p>首先，我们需要明确自己的角色，比如：</p>
<ul>
<li><p>以学业为主的初高中学生</p>
<p>初高中学生，最重要的目标则是学科学习，并且，学校规定的课堂学习已经占据了一天的大部分时间，并且通常在学校不被建议频繁使用手机，因此，在时间管理方面，最好采用纸质版规划的方式，需要被规划利用的时间通常为自习课以及周末、假期。</p>
</li>
<li><p>以课余时间为主提升的大学生研究生</p>
<p>对于大学生和研究生，课堂时间通常不会太多，这个时期更强调的是自律与自主，可利用的课余时间以及假期较多，是培养兴趣、提升自我的关键时期。</p>
</li>
<li><p>以业余时间为主提升的工作党</p>
<p>对于工作党，可自由利用的时间大多为业余时间，而不同的工作性质也决定了可利用大块时间的多少。这个时期是培养技能的黄金时期，不少人都有利用业余时间学习新技能或者扩展副业的需求</p>
</li>
<li><p>时间比较灵活的自由职业者等</p>
<p>对于自由职业者来说，可利用的时间很多，且具有很大的灵活性。但对自律的要求也更高，如果不好好管理并利用自己的时间，很有可能连维持自己生活的收入都难以搞定。</p>
</li>
</ul>
</li>
<li><p>时间的分类</p>
<p>在明晰自己角色之后，我们可以将自己的时间进行分类。我通常将时间分为被动时间和主动时间；</p>
<p>主动时间又可以分为整块时间和可使用外物的碎片化时间以及仅可用脑的碎片化时间。</p>
<ul>
<li><p>被动时间</p>
<p>什么是被动时间？<br>被动时间并不是指没有意义的时间，而是指比较固定的、已被安排的无法用于自我规划提升的时间：如课堂时间、上班时间、兼职时间、开会时间等。被动时间通常不需要做过多规划，只需要注意提醒自己不要忘记即可。</p>
</li>
<li><p>主动时间</p>
<p>主动时间是我们进行时间规划的重点部分，指的是我们可以灵活利用并安排分配的时间，可以分为整块时间、可使用外物的碎片化时间和仅可用脑的碎片化时间。</p>
<ul>
<li><p>整块时间</p>
<p>整块时间指的是可以在一段时间内不被打扰的、可以专注的主动时间。对于学生来说，自习课时间就是一种整块时间；以我自己为例，下班晚饭后，20点到22点通常被作为我的整块时间，除此之外，周末也是整块时间（与朋友相约则除外）。</p>
</li>
<li><p>可使用外物的碎片化时间</p>
<p>可使用外物的碎片化时间和仅可用脑的碎片化时间其实都是碎片化时间，之所以要将其单独分成两类，是因为这两种时间通常可以用来分配不同的事项，便于我们进行时间管理。</p>
<p>可使用外物的碎片化时间是指我们可以使用手机、书本等外物去完成待办事项或规划提升时间的碎片化时间，</p>
<p>这样的场景通常有：乘坐地铁、吃饭、化妆、做家务等。比如：我们可以利用乘坐地铁的时间在手机上看新闻；可以在吃饭的时候看学习视频；可以在化妆、做家务的时候听书等。</p>
</li>
<li><p>仅可用脑的碎片化时间</p>
<p>仅可用脑的碎片化时间指的是我们不能或不方便使用外物，但可以用脑思考规划的碎片化时间，这样的场景通常有洗澡、上厕所、骑车、运动健身、游泳等。比如：我们可以在洗澡的时候思考明日计划与安排；在游泳的时候思考某一篇文章的布局谋篇；在骑车的时候思考某一期视频的脚本等。</p>
<p>需要说明的是，以上时间与事件的分类并不是绝对的，对于每一个人来说都会有所不同，不必纠结具体事项。</p>
<p>比如，骑车这一事项，对有的人来说是可使用外物的碎片化时间，对有的人来说就是仅可用脑的碎片化时间，</p>
<p>我们更应该关注的是我想完成的事情应该怎么去完成，而不是去纠结时间分类的本身。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>时间管理系统该如何拆分</p>
<p>在对时间分类有了基本的了解之后，我们就可以开始进行时间管理系统的学习了。</p>
<p>我将时间管理系统分为：</p>
<ol>
<li><p>待办事项管理</p>
<ul>
<li><p>固定时间待办事项</p>
<p>固定时间的待办事项是指需要在指定时间段内完成的待办事项，</p>
<p>如：下午13点到14点的会议；下午17点的飞机；闺蜜周日的婚礼；周六下午的同学聚餐等。这类待办事项通常也被称作“日程”。</p>
</li>
<li><p>有截止时间的待办事项</p>
<p>有截止时间的待办事项是指只要在截止时间前完成即可的待办事项，</p>
<p>这类事项很容易被遗忘但遗忘后往往会有不好的结果，如：周六前完成整理好的报表并发送给领导；过年前完成核酸检测；在闺蜜的婚礼前挑选好结婚礼物等。</p>
</li>
<li><p>重复待办事项</p>
<p>重复待办事项是指有周期时间的待办事项，</p>
<p>如：每周末给家人打电话；每月5号花呗还款；每月10号信用卡还款；每周末收拾房间等。</p>
</li>
<li><p>无时间待办事项</p>
<p>无时间的待办事项指没有固定时间要求的待办事项，如买衣服；洗衣服；学习英语；学习如何剪辑视频；学习理财课程等。</p>
<p>可以发现，这部分待办事项，既有一些不太重要的琐碎事宜，也有一些对于自我提升很有意义的事项。</p>
<p>因此无时间待办事项可以细化为：</p>
<ul>
<li><p>短时行动类的无时间待办事项</p>
<p>如买衣服、洗衣服、收拾房间等可以在短时间内完成的没有时间需求的待办事项</p>
</li>
<li><p>长时行动类的无时间待办事项</p>
<p>如给家人分别准备新年礼物、制定旅游计划与攻略等需要较长时间来完成的没有时间需求的待办事项。</p>
</li>
<li><p>目标提升类的无时间待办事项</p>
<p>如学习英语、书籍阅读、学习理财等需要较长时间完成的具有学习提升属性的没有时间需求的待办事项。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>健康管理</p>
<p>健康管理是个被很多人忽视的版块。现在的手机占据了人们大部分的时间，很多年轻朋友们都经常性熬夜、不按时吃饭、睡眠不足或者运动量少，懒惰是人们的天性，过度的娱乐使我们的生活越来越不健康。为了让我们养成良好的生活习惯，保持足够的精力，我们需要进行健康模块的管理。</p>
<p>我将健康管理分为饮食健康、睡眠健康、运动健康三个大板块，而各位小伙伴可以根据自己的实际情况进行增减，比如女性朋友可以还可以增加生理期记录。</p>
</li>
<li><p>目标管理</p>
<p>关于目标的重要性，相信大家在上学时已经听老师们反复强调过。可能会有一部分同学认为：目标都是假大空的，我只想完成当前的事情。但实际上，目标对于我们的提升非常重要，我们只有先给自己制定一些目标，我们才会在日常生活中事事向着这个方向努力，并最终让目标成为事实。</p>
<p>待办事项管理让我们的每天能够顺利地进行下去，但只要实行过待办事项管理的人都会发现一个问题：那些没有时间的待办事项中，有一部分“重要不紧急”的事项，如英语学习、理财学习等，会逐渐被我们遗忘，如此一来，会让我们感觉自己每天都很忙碌，但又好像一无所成的样子。</p>
<p>这一部分的待办事项实际上就属于目标的一部分，掌握好目标管理的方法，可以帮助我们解决这一类问题。</p>
<p>目标管理通常以年为大单位，但为了更好地完成这些目标，我们需要细化到月目标和周目标。我通常将目标分为学习提升类目标和列表清单类目标。</p>
<ol>
<li><p>学习提升类目标</p>
<p>学习提升类目标主要包括各种课程学习、兴趣培养、副业开展等，比如：理财课程学习；英语口语训练；视频制作学习等。</p>
</li>
<li><p>列表清单类目标</p>
<p>列表清单类目标主要包括各种可以列举清单的目标，其单项的完成时间并不长，如：书单、观影清单、旅游清单等。</p>
</li>
</ol>
</li>
<li><p>总结记录与复盘</p>
<p>在总结记录与复盘中，主要包括：</p>
<ol>
<li>时间记录：时间统计法Toggl Track</li>
<li>目标进度：记录目标完成情况</li>
<li>日记&#x2F;周记&#x2F;月记&#x2F;年记：对自己一段时间的表现或者心情、感悟进行总结</li>
<li>备忘录：相当于一个“灵感清单”</li>
</ol>
<p>其中，时间记录可以根据实际需求选择舍弃。时间记录可以参考上文中提到的“时间统计法”，相关著作是《奇特的一生》，这里说可以选择舍弃时间记录，并不是指时间统计没有用，相反，如果能坚持记录下自己的时间，会大大提高自己对时间的把控力，帮助我们更好地规划时间、培养目标。但在实际生活中，时间记录是一个大工程，对自律的要求更高，有时候并不太适合大多数人，倘若因为对时间的记录而增加了时间管理的难度，或是为了记录而记录，反而是因小失大。另外，试想一下：倘若你的时间记录里面，充斥着大幅时间的娱乐、刷视频、发呆，你还会有心情进行时间管理吗？</p>
<p>目标进度主要是用来记录目标完成情况的，我们可以根据自己的需要，选择以周或月进行目标进度的更新。</p>
<p>日记&#x2F;周记&#x2F;月记&#x2F;年记其实就是对自己一段时间的表现或者心情、感悟进行总结，它的形式是非常灵活的，可以对自己的表现进行评分；可以记录自己的心情；也可以对当前的情况进行总结或是对未来提出期望。频率也由自己决定，可以选择每天记录、每周记录或者每月记录，一般年末可以再进行一个大总结。</p>
<p>备忘录则相当于一个“灵感清单”，你可以记录一些好的点子，也可以更新一些未来想要完成的事情，一些具有参考价值的信息也可以放入其中。</p>
</li>
</ol>
</li>
<li><p>手把手教你构建自己的时间管理系统</p>
<p>上文我们对主流的时间管理方法做了介绍，并将时间管理系统的组成部分逐一进行了拆解，也许到这里为止，你感觉脑子里有很多时间管理的知识，但又难以将其组合起来，内化为自己的时间管理方法，没有关系，接下来我将手把手带你构建自己的时间管理系统。</p>
<ul>
<li><p>事项收集</p>
<p>首先我们需要拿出一张白纸或打开一页空白的文档，放空自己的大脑，然后将你能想到的所有需要做的事情、闪过的点子都记录下来。</p>
<p>当你把大脑中的事项全部腾空，写在文档上之后，第一步的事项收集就算成功完成了，接下来我们进行第二步：事项分类。</p>
</li>
<li><p>事项分类：将待办事项细化</p>
<p>在这一步中，我们需要将待办事项细化，补足时间信息，文字动画，并将目前的所有待办事项按照</p>
<ul>
<li>固定时间待办事项、</li>
<li>有截止时间的待办事项、</li>
<li>重复待办事项、</li>
<li>短时行动类的无时间待办事项、</li>
<li>长时行动类的无时间待办事项</li>
<li>和目标提升类的无时间待办事项进行分类。</li>
</ul>
<p>将我上面列举的事项细化之后可以发现，</p>
<p>固定时间待办事项的有：</p>
<ul>
<li>元旦回老家</li>
<li>春节回家</li>
</ul>
<p>截止时间待办事项有：</p>
<ul>
<li>2月10日前买过年回家的车票。</li>
</ul>
<p>重复待办事项有：</p>
<ul>
<li>每天喂猫；</li>
<li>上班前关暖气；</li>
<li>每月20日信用卡还款；</li>
<li>每季度15日交房租；</li>
<li>每月10日蚂蚁花呗还款；</li>
<li>每天睡够8小时；</li>
<li>每天吃早餐；</li>
<li>运动以及眼保健操。</li>
</ul>
<p>短时行动类的无时间待办事项有：</p>
<ul>
<li>洗衣服；</li>
<li>收拾房间和整理相册。</li>
</ul>
<p>长时行动类的无时间待办事项有：</p>
<ul>
<li>去稻城旅游。</li>
</ul>
<p>最后目标提升类的无时间待办事项有：</p>
<ul>
<li>学习理财；</li>
<li>学习动画；</li>
<li>看5本书和看10部电影。</li>
</ul>
</li>
<li><p>事项规划：将你的目标拆分为具体的、可实行的待办事项</p>
<p>这一步我们需要将待办事项进行进一步的拆分细化，</p>
<p>在这一环节，你需要将你的目标拆分为具体的、可实行的待办事项，如具体的课程系列、具体的书单、运动的频率与时长等。</p>
<p>咱们还是看上面的例子，</p>
<p>其中，固定时间待办事项和截止时间待办事项已经比较具体，不需要继续细化。</p>
<p>重复待办事项中，如每天喂猫、上班前关暖气以及每月20号还款等事项也无需细化，但是运动这一项就需要进行进一步的拆分和细化。</p>
<p>大家试想一下，假如你的待办事项中有一项标题为“运动”的待办事项，那么当你实施起来的时候是不是会有点不知从何开始？我是跑步呢，还是做瑜伽，或是健身？</p>
<p>提前进行事项规划则可以提升我们的效率，并且可以帮助我们抵抗拖延症。</p>
<p>运动应该如何拆分呢？我这里举个例子，我感兴趣的运动方向包括：瘦腿、瘦肚子，在这两个重点运动方向之后才是全身瘦；那么接下来我们就可以去挑选适合的运动软件或者课程，如Keep、B站，最好是有可以跟练的视频；最后我们可以确定一下时间和频率，比如每周三天，每次30分钟。</p>
<p>接下来是眼保健操，这个比较简单，可以选择每天都做1次或者一周做5次。</p>
<p>短时行动类的无时间待办事项一般来说也不需要细化。</p>
<p>然后是长时行动类的无时间待办事项，这个基本上都需要我们进一步细化，<br>比如，我想去稻城旅游，那么我们可以细化为：确定时间、查看攻略、购买车票、预定酒店和预定门票，这样我们在进行规划时能够比较有条理。</p>
<p>最后一项是目标提升类的无时间待办事项，这一项也是我们细化的重点。<br>第一项学习理财，我们可以先去看一些他人的经验分享，这个经验可以是笼统性的，目的在于帮助我从中挑选我想要进一步学习的方向，那么最终我确定了记账和基金两个学习方向，方向确定之后我们就可以去寻找相关的课程了，比如理财基础知识、基金定投课程等。</p>
<p>下一个目标是学习动画，我们可以先列举一些自己感兴趣的方向，比如MG动画、角色动画、AE、C4D等，但由于时间和精力有限，我们无法同时进行学习，因此我先选择了最想学的C4D，并可以去寻找C4D动画课程，而剩下的方向可以用于下一次的规划。</p>
<p>然后是看5本书，10部电影，我们可以先把书籍和电影列举出来再看，也可以慢慢再更新，因为这属于清单类的目标事项，一本书、一部电影花费的时间并不算特别长，因此我们的计划很可能随时会变，所以边看边更新清单也是可以的</p>
</li>
<li><p>时间规划</p>
<p>接下来需要为已经具体化的待办事项制定初始的时间规划。这里我借鉴的是“一万小时理论”，为提升类目标制定一个时长规划，还是来到之前的例子，我们试着初步拟定一个时间规划方案：首先，去稻城旅游定在5月份的劳动节；学习理财定为一年200个小时，算下来每天平均32分钟；学习动画定为一年300个小时，平均每天50分钟。另外，两个月看一本书；一个月一部电影。</p>
<p>这一步的目的是通过计算时间来预估自己的规划是否合理，以及目标是否可以被完成。</p>
<p>目前的规划中，每天约有80min的学习提升时间，还需要预留读书和看电影的时间，计划比较合理。有以下注意事项：</p>
<ol>
<li>目标时间不要过长，需要留出突发事件的时间，以及偶尔懒惰带来的时间浪费</li>
<li>不需要精确计划时间，避免计划混乱带来的挫败感</li>
<li>这里并不是说每天必须学习这么长时间，前一天学习的时间少了，可以后面再补回来，算出每天的时间只是为了让大家知道你的时间是否合理。</li>
</ol>
</li>
<li><p>工具配合</p>
<p>在这个过程中，你可能会试用很多软件，但只要你的时间管理系统足够稳定，你就不会被这个工具搜寻的过程打败，切记的是：<strong>不要为了去适配你搜寻到工具软件，而去反复调整你自己的时间管理系统。</strong></p>
<ul>
<li><p>待办事项分类：时光序</p>
</li>
<li><p>五类待办事项创建：时光序</p>
<p>操作：在这一步中，我们需要参考时间规划中得出的清单，将固定时间的待办事项、有截止时间的待办事项、重复待办事项、短时行动类的无时间待办事项和长时行动类的无时间待办事项这五类待办事项在软件中按照自己定义的清单分别创建。</p>
</li>
<li><p>目标管理系统创建：<a href="https://shimo.im/sheets/rPdPGcJOYD8BZTVp/MODOC/">石墨文档</a></p>
</li>
<li><p>目标提升类待办事项创建</p>
<p>目标管理系统已经搭建完成，可以发现，我们多了几项目标提升类的无时间待办事项，我们需要将本周的周目标以待办的形式在时光序中创建，可以先不确定时间。</p>
</li>
<li><p>待办事项整体优化</p>
</li>
<li><p>待办事项的时间安排</p>
</li>
<li><p>待办事项执行方法：工具：番茄ToDo</p>
</li>
<li><p>总结记录与复盘</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Goal</category>
      </categories>
      <tags>
        <tag>Goal</tag>
      </tags>
  </entry>
  <entry>
    <title>How to build yourself cognitive system</title>
    <url>/2023/12/07/How%20to%20build%20yourself%20cognitive%20system/</url>
    <content><![CDATA[<h3 id="如何有效地构建自己的知识体系"><a href="#如何有效地构建自己的知识体系" class="headerlink" title="如何有效地构建自己的知识体系?"></a>如何有效地构建自己的知识体系?</h3><ol>
<li><p>相关性</p>
<p>优先学习那些与当前工作相关的内容,这样可以使自己处于舒适区边缘,不断扩展自己的边界,又由于相关性的存在,能够快速高效地学习提升。</p>
</li>
<li><p>点-&gt;线-&gt;面-&gt;图:链接</p>
<p>使用自己的语言周期性整理自己的知识,并在实践中练习或使用。</p>
</li>
<li><p>所谓知识体系就是:在舒适区边缘一点点向外扩张自己的小宇宙</p>
</li>
</ol>
<h3 id="什么是你自己的知识"><a href="#什么是你自己的知识" class="headerlink" title="什么是你自己的知识?"></a>什么是你自己的知识?</h3><p>当问题发生时,没有人告诉你怎么办,你通过一套有效的处理流程做出了正确的决策与判断,这就是你自己的知识。</p>
<p>真正的知识不是你知道了它，而是能运用它帮助自己做出正确的判断、选择、行动、改变和解决实际问题。</p>
<p>你学到的知识，只有能够应用，才是真正属于你的。</p>
<h3 id="两种知识-三个层次"><a href="#两种知识-三个层次" class="headerlink" title="两种知识,三个层次"></a>两种知识,三个层次</h3><p>普朗克获得诺贝尔奖之后，到德国各地作演讲，每次讲的内容大同小异，都是关于新的量子物理理论的，时间一久，他的司机记住了讲座的内容。</p>
<p>司机说：“普朗克教授，我们老这样也挺无聊的，不如这样吧，到慕尼黑让我来讲，你戴着我的司机帽子坐在前排，你说呢？”</p>
<p>普朗克说：“好啊。”于是司机走上讲台，就量子物理发表了一通长篇大论。后来有个物理学教授站起来，提了一个非常难的问题。</p>
<p>演讲者说：“哇，我真没想到，我会在慕尼黑这么先进的城市遇到这么简单的问题。我想请我的司机来回答。”</p>
<p>这是查理芒格最喜欢讲的一个故事。</p>
<p>芒格讲这个故事，并不是为了表扬司机很机敏。</p>
<p>在芒格看来，这个世界的知识可以分为两种：</p>
<ul>
<li><p>一种是普朗克知识，它属于那种真正懂的人。他们付出了努力，他们拥有那种能力。</p>
</li>
<li><p>另外一种是司机知识。</p>
<p>他们掌握了鹦鹉学舌的技巧；他们可能有漂亮的头发；他们的声音通常很动听；他们给人留下深刻的印象。但其实他们拥有的是伪装成真实知识的司机知识。</p>
</li>
</ul>
<p>掌握知识的三个层次</p>
<ol>
<li><p>有生长能力的知识</p>
<p>普朗克的知识是有生长能力的。他的知识可以不断发展，可以生出新的知识，可以应对许多问题。即便是从未遇到的问题，都能给出见解。</p>
<p>如此掌握知识的内在特点就是体系化。外在特点是有大用途。</p>
<p>所谓体系化是指从知识源头的基本问题、基本概念、基本定理、到应用，有一整套逻辑的过程。</p>
</li>
<li><p>鹦鹉学舌的模仿知识</p>
<p>鹦鹉学舌的模仿知识，虽然不成体系，但也有两个明显的优点。内在，虽然不可生长，但却是模块化的。外在，可以用来干许多事情，但难以干大事。</p>
<p>这些模块化的知识最大的用处就是忽悠人。如同芒格所说，司机知识至少可以用来撑场面，甚至达到以假乱真的程度。政客正是因为掌握了大量的模块化知识，所以可以滔滔不绝，对下可以用来忽悠大众，也可以用来跟对手论辩。</p>
</li>
<li><p>破碎化的知识</p>
<p>破碎化的知识的特点当然是破碎的。用处就是作为谈资，跟人聊天可以，辩论就不行了，应用起来错误百出、不堪其用。</p>
<p>破碎化的知识都是零散的搜集来的，或者道听途说，或者引章摘句。</p>
</li>
</ol>
<p>想要爆发自己的小宇宙，体系化的学习是不可逾越的，别无他途。</p>
<p>要么找到自己的人生目标，知道该学什么。要么，人生如戏，把学习当作游戏，给自己颁发成就奖章。</p>
<h3 id="编程经验"><a href="#编程经验" class="headerlink" title="编程经验"></a>编程经验</h3><ul>
<li>越靠近底层（语言、算法、数据结构、HTTP、TCP……）与越靠近高层（分层、组件、概念、理论、模式、经验、思想、平衡）的知识和经验越少且稳定</li>
<li>而越靠近中间（框架、工具）越多且不稳定</li>
</ul>
<h3 id="程序员学习路线"><a href="#程序员学习路线" class="headerlink" title="程序员学习路线"></a>程序员学习路线</h3><p>程序员应该遵照下面的路线去规划自己的学习路线：</p>
<ol>
<li>确定一个技能培养目标</li>
<li>搜集这个技能相关领域的书籍列表</li>
<li>找到相关领域最顶级的三本书</li>
<li>读这三本书</li>
<li>练习书中所说的内容</li>
<li>向别人展示自己练习的结果，别人是高手最好</li>
<li>虚心接受一切批评和反馈，即使这种批评惨无人道，即使那些反馈非常严苛觉得自己不够精通，GOTO第4步</li>
<li>觉得自己已经很牛了,GOTO第1步</li>
</ol>
]]></content>
      <categories>
        <category>Goal</category>
      </categories>
      <tags>
        <tag>Goal</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core API Best Practices</title>
    <url>/2023/11/23/NET%20Core%20API%20Best%20Practices/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="1、紧密耦合"><a href="#1、紧密耦合" class="headerlink" title="1、紧密耦合"></a>1、紧密耦合</h3><p>​		 避免在控制器中声明特定的依赖项实例，应该使用依赖注入系统将依赖项注入到控制器中。后者避免了紧密耦合，更加易于维护和测试。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    ProductService productService = <span class="keyword">new</span> ProductService();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;ProductController&gt; _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IProductService _productService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductController</span>(<span class="params">IProductService productService, ILogger&lt;ProductController&gt; logger</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _productService = productService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、Mixing-Concerns功能混淆"><a href="#2、Mixing-Concerns功能混淆" class="headerlink" title="2、Mixing Concerns功能混淆"></a>2、Mixing Concerns功能混淆</h3><p>​		 控制器应专注于 HTTP 请求和生成响应。避免混合身份验证、授权或任何其他验证等问题，而是使用中间件或任何单独的类或服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Authentication and authorization logic here</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Data access logic here</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、缺乏异常处理"><a href="#3、缺乏异常处理" class="headerlink" title="3、缺乏异常处理"></a>3、缺乏异常处理</h3><p>​		 避免在控制器中使用 try-catch 块，而是使用异常中间件来更好地处理异常以返回一般错误消息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid (Inconsistent error handling or try catch everywhere</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ProductValidationException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BadRequest(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogError(ex, <span class="string">&quot;An error occurred while creating the product.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> StatusCode(StatusCodes.Status500InternalServerError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer Exception filters or Middleware</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、长时操作"><a href="#4、长时操作" class="headerlink" title="4、长时操作"></a>4、长时操作</h3><p>​		避免在控制器中执行长时间运行的操作。相反，应该把长时操作加入到后台运行的队列中，以避免系统停止服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GenerateReport</span>(<span class="params">Report report</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Long-running operation</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(report);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GenerateReport</span>(<span class="params">Report report</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> taskIdentifier = <span class="keyword">await</span> _messageQueueService.EnqueueAsync(report);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StatusCode(StatusCodes.Status202Accepted, taskIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、缺少验证"><a href="#5、缺少验证" class="headerlink" title="5、缺少验证"></a>5、缺少验证</h3><p>​		输入验证对于确保系统的完整性和安全性至关重要。避免忽视控制器中的输入验证。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// No validation</span></span><br><span class="line">    <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line">    <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">[FromBody] ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> StatusCode(StatusCodes.Status400BadRequest, ModelState);                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line">    <span class="keyword">return</span> Ok(StatusCodes.Status201Created);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、直接访问数据库"><a href="#6、直接访问数据库" class="headerlink" title="6、直接访问数据库"></a>6、直接访问数据库</h3><p>​		避免直接访问数据库，而是使用服务或存储库将控制器与特定的数据访问技术分离。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> product = dbContext.Products.Find(productId);</span><br><span class="line">    <span class="keyword">return</span> Ok(product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> product = <span class="keyword">await</span> _productService.GetByIdAsync(productId);</span><br><span class="line">    <span class="keyword">return</span> Ok(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、缺乏缓存"><a href="#7、缺乏缓存" class="headerlink" title="7、缺乏缓存"></a>7、缺乏缓存</h3><p>​		在适当的时候实施缓存机制。利用缓存来提高性能并减少服务器上的负载。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoi</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProducts</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> products = <span class="keyword">await</span> _productService.GetAllAsync();</span><br><span class="line">    <span class="keyword">return</span> Ok(products);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line">[<span class="meta">ResponseCache(Duration = 60)</span>] <span class="comment">// Cache the response for 60 seconds</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProducts</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> products = <span class="keyword">await</span> _productService.GetAllAsync();</span><br><span class="line">    <span class="keyword">return</span> Ok(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、缺乏身份验证和授权"><a href="#8、缺乏身份验证和授权" class="headerlink" title="8、缺乏身份验证和授权"></a>8、缺乏身份验证和授权</h3><p>​		对敏感操作实施身份验证和授权。相应地保护控制器和操作方法的安全访问。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoi</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">DeleteProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// No authentication or authorization</span></span><br><span class="line">    <span class="keyword">await</span> _productService.DeleteAsync(productId);</span><br><span class="line">    <span class="keyword">return</span> StatusCode(StatusCodes.Status200OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line">[<span class="meta">Authorize(Roles = <span class="string">&quot;Admin&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">DeleteProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> _productService.DeleteAsync(productId);</span><br><span class="line">    <span class="keyword">return</span> StatusCode(StatusCodes.Status200OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、逻辑过多"><a href="#9、逻辑过多" class="headerlink" title="9、逻辑过多"></a>9、逻辑过多</h3><p>​		避免过多的逻辑。控制器应主要负责处理传入请求和返回响应。对于任何复杂的逻辑，应使用单独的实用程序或服务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProducts</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Complex business logic here</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> Ok(products);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">GetProducts</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> products = <span class="keyword">await</span> _productService.GetAllAsync();</span><br><span class="line">    <span class="keyword">return</span> Ok(products);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、忽略-HTTP-动词实现RESTful-原则"><a href="#10、忽略-HTTP-动词实现RESTful-原则" class="headerlink" title="10、忽略 HTTP 动词实现RESTful 原则"></a>10、忽略 HTTP 动词实现RESTful 原则</h3><p>​		ASP.NET Core 中的控制器应遵循 RESTful 架构的原则。避免使用不符合 RESTful 约定的不当 HTTP 谓词或操作。使用适当的 HTTP 动词（GET、POST、PUT、DELETE 等）。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">DeleteProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpDelete(<span class="string">&quot;/api/products/&#123;id&#125;&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">DeleteProduct</span>(<span class="params"><span class="built_in">int</span> productId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11、缺乏正确的路由"><a href="#11、缺乏正确的路由" class="headerlink" title="11、缺乏正确的路由"></a>11、缺乏正确的路由</h3><p>​		确保控制器已正确路由以处理传入请求。避免不一致或不明确的路由配置。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpGet</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer:</span></span><br><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;api/products&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12、缺少日志"><a href="#12、缺少日志" class="headerlink" title="12、缺少日志"></a>12、缺少日志</h3><p>​		日志记录是应用程序开发的一个非常关键的方面，因为它有助于在代码执行期间跟踪重要事件、条件和错误。使用中间件或操作筛选器捕获相关信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Avoid</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (someSimpleCondition)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line">    <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prefer</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">CreateProduct</span>(<span class="params">ProductDto productDto</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (someSimpleCondition)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        _logger.LogWarning(<span class="string">&quot;Warning: Some simple condition is met.&quot;</span>); <span class="comment">// Log a warning</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">await</span> _productService.CreateAsync(productDto);</span><br><span class="line">     <span class="keyword">return</span> Ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<ol>
<li><a href="https://www.linkedin.com/pulse/12-bad-practices-avoid-aspnet-core-api-controllers-muhammad-kamran/">12 Bad Practices to Avoid in ASP.NET Core API Controllers</a></li>
</ol>
]]></content>
      <categories>
        <category>.NETCore</category>
      </categories>
      <tags>
        <tag>.NETCore</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Programmer Competency Matrix</title>
    <url>/2023/12/07/Programmer%20Competency%20Matrix/</url>
    <content><![CDATA[<p>原文：<a href="http://sijinjoseph.com/programmer-competency-matrix/">Programmer Competency Matrix</a></p>
<p><strong>注意：每个水平的知识是累积的</strong></p>
<table>
<thead>
<tr>
<th><div style="width=100px;">计算机科学</div></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>2n (0级)</td>
<td>N2(第1级)</td>
<td>N (第2级)</td>
<td>Log  (n)(第3级)</td>
</tr>
<tr>
<td>数据结构</td>
<td>不知道数组和链表的区别</td>
<td>能够解释和在实际编程任务中使用数组、链接列表、字典等</td>
<td>懂得权衡基本数据结构，数组与链接列表空间和时间，能够解释如何实现哈希表并可处理碰撞，优先级队列以及如何实现等</td>
<td>懂得高级数据结构，如B树的知识，二项式堆和斐波那契堆，AVL&#x2F;红黑树中，展开树，跳跃表，尝试等</td>
</tr>
<tr>
<td>算法</td>
<td>不能找到数组中的平均值</td>
<td>基本排序、搜索和遍历数据结构和检索算法</td>
<td>树图，简单的贪婪和分治算法，能理解这个矩阵水平的相关性。</td>
<td>能够识别和编写动态规划解，具有良好的图形算法的知识，良好的数值计算算法的知识，能够识别NP问题等</td>
</tr>
<tr>
<td>系统程序设计</td>
<td>不知道什么是编译器、链接器或解释器</td>
<td>对编译器、链接器和解释器有基本的理解。理解什么是汇编代码，以及在硬件级别上是如何工作的。关于虚拟内存和分页的一些知识</td>
<td>理解内核模式与用户模式、多线程、同步原语以及它们是如何实现的，能够读懂汇编代码。了解网络如何工作，了解网络协议和套接字级别的编程</td>
<td>了解整个编程堆栈，硬件(CPU  + 内存 + 缓存 + 中断 + 微代码) ，二进制代码，汇编，静态和动态链接，编译，解释，JIT 编译，垃圾收集，堆，堆栈，内存寻址..</td>
</tr>
<tr>
<td><strong>软件工程</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2n (0级)</td>
<td>N2(第1级)</td>
<td>N (第2级)</td>
<td>Log (n)(第3级)</td>
</tr>
<tr>
<td>源代码版本控制源代码版本控制</td>
<td>按日期备份文件夹</td>
<td>TFS 和初始SVN用户</td>
<td>熟练使用 TFS 和 SVN 特性。知道如何分支和合并，使用补丁设置存储库属性等</td>
<td>了解分布式 VCS 系统。已经尝试过  Git</td>
</tr>
<tr>
<td>自动化构建</td>
<td>只知道如何从 IDE 构建</td>
<td>知道如何从命令行构建系统</td>
<td>可以设置脚本来构建基本的系统</td>
<td>可以设置脚本来构建系统，也可以设置文档、安装程序、生成发布说明和标记源代码控制中的代码</td>
</tr>
<tr>
<td>自动化测试</td>
<td>认为所有的测试都是测试人员的工作</td>
<td>编写了自动化的单元测试，并为正在编写的代码提供了良好的单元测试用例</td>
<td>以 TDD 方式编写代码</td>
<td>理解并能够设置自动化的功能、负载&#x2F;性能和 UI 测试</td>
</tr>
<tr>
<td><strong>编程</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2n (0级)</td>
<td>N2(第1级)</td>
<td>N (第2级)</td>
<td>Log (n)(第3级)</td>
</tr>
<tr>
<td>问题分解</td>
<td>只有复制粘贴的直线代码可重用</td>
<td>能够将问题分解为多个函数</td>
<td>能够提出可重用的函数&#x2F;对象来解决整个问题</td>
<td>使用适当的数据结构和算法，并提出通用的&#x2F;面向对象的代码，这些代码封装了可能发生变化的问题的各个方面</td>
</tr>
<tr>
<td>系统分解</td>
<td>无法超越单个文件&#x2F;类的级别进行思考</td>
<td>能够打破问题空间和设计解决方案，只要它是在相同的平台&#x2F;技术</td>
<td>能够设计跨多种技术&#x2F;平台的系统</td>
<td>能够可视化和设计复杂的系统与多个产品线和与外部系统的集成。还应该能够设计操作支持系统，如监视，报告，故障转移等</td>
</tr>
<tr>
<td>沟通</td>
<td>不能向同龄人表达思想&#x2F;想法。拼写和语法不好</td>
<td>同龄人能听懂别人在说什么。拼写和语法都很好</td>
<td>能够有效地与同伴交流</td>
<td>能够明确的方式理解和沟通的想法&#x2F;设计&#x2F;创意&#x2F;规格和在不同的上下文中调整</td>
</tr>
<tr>
<td>文件中的代码组织</td>
<td>档案中没有组织的证据</td>
<td>方法按逻辑或可访问性分组</td>
<td>代码按区域分组，并使用对其他源文件的引用进行了很好的注释</td>
<td>文件有许可头，摘要，很好的注释，一致的空白使用。文件应该看起来漂亮</td>
</tr>
<tr>
<td>跨文件的代码组织</td>
<td>没有考虑跨文件组织代码</td>
<td>相关文件被分组到一个文件夹中</td>
<td>每个物理文件都有一个独特的用途，例如一个类定义，一个特性实现等</td>
<td>代码组织在物理层面上与设计紧密匹配，通过查看文件名和文件夹分布可以深入了解设计</td>
</tr>
<tr>
<td>源码组织</td>
<td>所有东西都放在一个文件夹里</td>
<td>将代码分成逻辑文件夹的基本方法</td>
<td>没有循环依赖项、二进制文件、库、文档、构建、第三方代码全部组织到适当的文件夹中</td>
<td>源码的物理布局与逻辑层次结构和组织相匹配。目录名称和组织提供了对系统设计的深入了解</td>
</tr>
<tr>
<td>代码可读性</td>
<td>单音节的名字</td>
<td>文件、变量类、方法等的好名字</td>
<td>没有长函数，非常规代码、错误修复、代码假设的注释</td>
<td>代码假设使用断言进行验证，代码自然流动——没有条件或方法的深度嵌套</td>
</tr>
<tr>
<td>防御性编码</td>
<td>不明白这个概念</td>
<td>检查代码中的所有参数并断言关键假设</td>
<td>确保检查返回值并检查围绕可能失败的代码的异常</td>
<td>拥有自己的库来帮助进行防御性编码，编写模拟错误的单元测试</td>
</tr>
<tr>
<td>错误处理</td>
<td>只有正常情况下的代码</td>
<td>围绕可能引发异常&#x2F;生成错误的代码的基本错误处理</td>
<td>确保错误&#x2F;异常使程序处于良好状态，资源、连接和内存都被正确清理</td>
<td>在可能的异常之前进行代码检测，在所有的代码层保持一致的异常处理策略，为整个系统  提出了异常处理的指导方针</td>
</tr>
<tr>
<td>IDE</td>
<td>主要使用 IDE 进行文本编辑</td>
<td>了解IDE的界面，能够有效地使用 IDE菜单</td>
<td>了解大多数常用操作的键盘快捷键</td>
<td>编写了自定义宏</td>
</tr>
<tr>
<td>API</td>
<td>需要经常查找文档</td>
<td>记得最常用的 API</td>
<td>对 API 有广泛而深入的了解</td>
<td>编写了位于 API 之上的库，以简化经常使用的任务并填补 API 中的空白</td>
</tr>
<tr>
<td>架构</td>
<td>没有使用核心平台之外的任何框架</td>
<td>听说过但没有使用过该平台可用的流行框架</td>
<td>以专业人员身份使用过不止一个框架，熟悉框架的习惯用法</td>
<td>框架的作者</td>
</tr>
<tr>
<td>需求</td>
<td>根据规格要求和代码</td>
<td>在规范中提出有关遗漏用户用例的问题</td>
<td>了解完整的用户用例，并提出整个领域需要规格</td>
<td>能够根据经验提出更好的备选方案和流程以满足给定的需求</td>
</tr>
<tr>
<td>脚本</td>
<td>不懂脚本工具</td>
<td>了解批处理文件&#x2F;shell 脚本</td>
<td>了解Perl&#x2F;Python&#x2F;Ruby&#x2F;VBScript&#x2F;Powershell语言</td>
<td>编写并发布可重用代码</td>
</tr>
<tr>
<td>数据库</td>
<td>认为 Excel 是一个数据库</td>
<td>了解基本的数据库概念、规范化、 ACID、事务，能够编写简单的查询</td>
<td>能够设计良好和规范化的数据库模式，牢记需要运行的查询，熟练使用视图、存储过程、触发器和用户定义的类型。知道聚集索引和非聚集索引之间的区别。熟练使用 ORM 工具</td>
<td>能够进行基本的数据库管理、性能优化、索引优化、编写高级选择查询、能够用关系 sql 替换游标的使用、理解数据如何在内部存储、理解索引如何在内部存储、理解数据库如何镜像、复制等。了解两阶段提交的工作原理</td>
</tr>
<tr>
<td><strong>经验</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2n (0级)</td>
<td>N2(第1级)</td>
<td>N (第2级)</td>
<td>Log (n)(第3级)</td>
</tr>
<tr>
<td>有专业的语言经验</td>
<td>命令式或面向对象</td>
<td>命令式的、面向对象的和声明式的(SQL) ，如果他们理解静态类型和动态类型，弱类型和强类型以及静态推断类型，就会有额外的好处</td>
<td>功能性的，如果他们了解懒惰的评估，咖喱，延续，增加奖金</td>
<td>并发(Erlang，Oz)和逻辑(Prolog)</td>
</tr>
<tr>
<td>有专业经验的平台</td>
<td>1个</td>
<td>两到三个(如C#与Python)</td>
<td>4-5个</td>
<td>6个以上</td>
</tr>
<tr>
<td>多年的专业经验</td>
<td>1年</td>
<td>2-5年</td>
<td>6-9年</td>
<td>10年以上</td>
</tr>
<tr>
<td>领域知识</td>
<td>对这个领域一无所知</td>
<td>已经在该领域中至少开发了一个产品</td>
<td>曾在同一领域的多个产品上工作</td>
<td>领域专家。设计并实现了该领域的几个产品&#x2F;解决方案。精通该领域使用的标准术语和协议</td>
</tr>
<tr>
<td><strong>知识</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>工具知识</td>
<td>仅限于主要IDE (VS.Net, Eclipse etc.)</td>
<td>了解一些流行和标准工具的替代品</td>
<td>熟悉编辑器、调试器、 IDE、开放源代码等。例如，有人知道 Scott Hanselman 的电动工具列表中的大部分工具。使用了 ORM 工具</td>
<td>实际上已经编写了工具和脚本，如果他们已经发布了额外的奖金</td>
</tr>
<tr>
<td>接触到的语言</td>
<td>命令式或面向对象</td>
<td>命令式的、面向对象的和声明式的(SQL) ，如果他们理解静态类型和动态类型，弱类型和强类型以及静态推断类型，就会有额外的好处</td>
<td>功能性的，如果他们了解懒惰的评估，咖喱，延续，增加奖金</td>
<td>并发(Erlang，Oz)和逻辑(Prolog)</td>
</tr>
<tr>
<td>代码库知识</td>
<td>从没看过代码库</td>
<td>代码布局的基本知识以及如何构建系统</td>
<td>良好的代码库工作知识，已经实现了几个 bug 修复，可能还有一些小特性</td>
<td>已经在代码库中实现了多个大特性，并且可以很容易地显示大多数特性或  bug 修复所需的更改</td>
</tr>
<tr>
<td>对未来技术的了解</td>
<td>没有听说过即将到来的技术</td>
<td>听说了这个领域即将出现的新技术</td>
<td>已经下载了 alpha 预览版&#x2F;CTP&#x2F;beta  并阅读了一些文章&#x2F;手册</td>
<td>玩过预告片，并且实际上已经用它建立了一些东西，作为奖励，与其他人分享</td>
</tr>
<tr>
<td>平台内部结构</td>
<td>对平台内部原理一无所知</td>
<td>具有平台内部工作的基本知识</td>
<td>深入了解平台的内部原理，可以直观地看到平台是如何将程序转换成可执行代码的</td>
<td>编写了增强或提供平台内部信息的工具，例如反汇编程序、反编译程序、调试程序等</td>
</tr>
<tr>
<td>书</td>
<td>21天系列，24小时系列，傻瓜系列..</td>
<td>《代码大全》,   《Don’t Make me Think不要让我思考》,   《Mastering  Regular Expressions掌握正则表达式》</td>
<td>Design Patterns设计模式,   Peopleware,  Programming Pearls编程珠玑,   Algorithm Design Manual算法设计手册,   Pragmatic Programmer实用程序员,   Mythical Man month 人月  神话</td>
<td>Structure and Interpretation of Computer Programs计算机程序的构造和解释,   Concepts Techniques概念技术,   Models of Computer Programming计算机编程模型,   Art of Computer Programming, Database systems , by C. J Date,  Thinking Forth计算机编程艺术,   Little Schemer 数据库系统</td>
</tr>
<tr>
<td>博客</td>
<td>听说过，但从来没有时间阅读</td>
<td>阅读科技&#x2F;编程&#x2F;软件工程博客，定期收听播客</td>
<td>维护一个链接博客，收集一些他&#x2F;她收集的有用的文章和工具</td>
<td>维护一个博客，在其中分享个人对编程的见解和想法</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Goal</category>
      </categories>
      <tags>
        <tag>Goal</tag>
      </tags>
  </entry>
  <entry>
    <title>Publish Nuget from 0 to 1</title>
    <url>/2023/06/26/Publish%20Nuget%20from%200%20to%201/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Nuget"><a href="#Nuget" class="headerlink" title="Nuget"></a>Nuget</h2><h3 id="1、创建示例项目"><a href="#1、创建示例项目" class="headerlink" title="1、创建示例项目"></a>1、创建示例项目</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">--</span>创建文件夹EasyUtilityCore</span><br><span class="line"><span class="built_in">md</span> EasyUtilityCore</span><br><span class="line"><span class="built_in">cd</span> EasyUtilityCore</span><br><span class="line"></span><br><span class="line"><span class="literal">--</span>新建EasyUtilityCore类库</span><br><span class="line">dotnet new classlib</span><br></pre></td></tr></table></figure>

<p>新建扩展StringExtension</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EasyUtilityCore</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtension</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 忽略空格与大小写</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;strA&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;strB&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CompareIgnoreCaseAndSpace</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> strA, <span class="built_in">string</span> strB</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strA == <span class="literal">null</span> || strB == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> strA == strB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> strA.Trim().ToLower() == strB.Trim().ToLower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 超长字符串截取</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 处理较短字符串截取Case</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;length&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;index&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Sub</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str, <span class="built_in">int</span> length, <span class="built_in">int</span> index = <span class="number">0</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str.Substring(index, Math.Min(str.Length, length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--构建类库</span><br><span class="line">dotnet build</span><br></pre></td></tr></table></figure>

<h3 id="2、添加包元数据"><a href="#2、添加包元数据" class="headerlink" title="2、添加包元数据"></a>2、添加包元数据</h3><p>每个 NuGet 包都需要一个清单，用以描述包的内容和依赖项。 在最终包中，清单是基于项目文件中包含的 NuGet 元数据属性生成的 文件。</p>
<p>打开 <em>.csproj</em>项目文件，并在现有 <code>&lt;PropertyGroup&gt;</code> 标记中添加以下属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PackageId</span>&gt;</span>EasyUtilityCore<span class="tag">&lt;/<span class="name">PackageId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Authors</span>&gt;</span>wzyandi<span class="tag">&lt;/<span class="name">Authors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Company</span>&gt;</span>wzyandi<span class="tag">&lt;/<span class="name">Company</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Description</span>&gt;</span>Some common extension methods<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RepositoryUrl</span>&gt;</span>https://github.com/amerina/EasyUtilityCore<span class="tag">&lt;/<span class="name">RepositoryUrl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageProjectUrl</span>&gt;</span>https://github.com/amerina/EasyUtilityCore<span class="tag">&lt;/<span class="name">PackageProjectUrl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RepositoryType</span>&gt;</span>Git<span class="tag">&lt;/<span class="name">RepositoryType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackageTags</span>&gt;</span>ASP.NET Core,Utility Method<span class="tag">&lt;/<span class="name">PackageTags</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Copyright</span>&gt;</span>Amerina<span class="tag">&lt;/<span class="name">Copyright</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PackageId在 nuget.org必须是唯一的。</p>
<h3 id="3、构建包"><a href="#3、构建包" class="headerlink" title="3、构建包"></a>3、构建包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet pack</span><br></pre></td></tr></table></figure>

<p>查看EasyUtilityCore\bin\Debug路径已生成EasyUtilityCore.1.0.0.nupkg文件</p>
<h3 id="4、发布包"><a href="#4、发布包" class="headerlink" title="4、发布包"></a>4、发布包</h3><p>将 <em>.nupkg</em> 文件发布到 nuget.org，方法是将 dotnet nuget push命令与从 nuget.org 获取的 API 密钥配合使用。</p>
<p>获取 API 密钥</p>
<ol>
<li><a href="https://www.nuget.org/users/account/LogOn?returnUrl=/">登录你的 nuget.org 帐户</a>，或创建一个帐户（如果你还没有帐户）。</li>
<li>选择用户名（在右上角），然后选择“API 密钥”。</li>
<li>选择 <strong>“创建”</strong>，并提供密钥的名称。</li>
<li>在 <strong>“选择范围”</strong>下，选择“ <strong>推送</strong>”。</li>
<li>在 <strong>“选择包</strong>&gt;<strong>Glob 模式</strong>”下，输入 *。</li>
<li>选择“创建”。</li>
<li>选择 <strong>“复制</strong> ”以复制新密钥。</li>
</ol>
<p>在包含 <em>.nupkg</em> 文件的文件夹运行以下命令。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dotnet nuget push EasyUtilityCore.<span class="number">1.0</span>.<span class="number">0</span>.nupkg <span class="literal">-key</span> [<span class="type">yourKey</span>] <span class="literal">-s</span> https://api.nuget.org/v3/index.json</span><br></pre></td></tr></table></figure>

<h3 id="5、包版本控制"><a href="#5、包版本控制" class="headerlink" title="5、包版本控制"></a>5、包版本控制</h3><p>特定版本号的格式为 Major.Minor.Patch[-Suffix] ，其中的组件具有以下含义：</p>
<ul>
<li><em>Major</em>：重大更改</li>
<li><em>Minor</em>：新增功能，但可向后兼容</li>
<li><em>Patch</em>：仅可向后兼容的 bug 修复</li>
<li><em>-Suffix</em>（可选）：连字符后跟字符串，表示预发布版本</li>
</ul>
<p>-Suffix-包开发人员通常遵循识别的命名约定：</p>
<ul>
<li><code>-alpha</code>：Alpha 版本，通常用于在制品和试验品。</li>
<li><code>-beta</code>：Beta 版本，通常指可用于下一计划版本的功能完整的版本，但可能包含已知 bug。</li>
<li><code>-rc</code>：候选发布，通常可能为最终（稳定）版本，除非出现重大 bug。</li>
</ul>
<h3 id="6、参考"><a href="#6、参考" class="headerlink" title="6、参考"></a>6、参考</h3><p><a href="https://learn.microsoft.com/zh-cn/nuget/what-is-nuget">NuGet 及其功能介绍 | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/zh-cn/nuget/nuget-org/package-readme-on-nuget-org">NuGet.org 上的包自述文件 | Microsoft Learn</a></p>
]]></content>
      <categories>
        <category>Nuget</category>
      </categories>
      <tags>
        <tag>Nuget</tag>
      </tags>
  </entry>
  <entry>
    <title>Time Will Tell Me The Answer</title>
    <url>/2023/11/28/Time%20Will%20Tell%20Me%20The%20Answer/</url>
    <content><![CDATA[<h3 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h3><h4 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h4><ul>
<li>DataStructure in C# Not Only List</li>
</ul>
<h4 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h4><ul>
<li>Classes</li>
<li>Composition组合</li>
<li>Inheritance继承</li>
<li>Polymorphism多态</li>
<li>Interfaces接口</li>
</ul>
<h4 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h4><ul>
<li>Generics泛型</li>
<li>Delegates委托</li>
<li>Lambda Expressions</li>
<li>Events事件</li>
<li>LINQ</li>
<li>Nullable Types可空类型</li>
<li>Dynamic动态类型</li>
<li>Exception Handling异常处理</li>
<li>Asynchronous Programming With Async&#x2F;Await</li>
</ul>
<h3 id="ASP-NET-Core框架"><a href="#ASP-NET-Core框架" class="headerlink" title="ASP.NET Core框架"></a>ASP.NET Core框架</h3><h4 id="一次请求的奇妙旅程"><a href="#一次请求的奇妙旅程" class="headerlink" title="一次请求的奇妙旅程"></a>一次请求的奇妙旅程</h4><h4 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h4><h4 id="Life-Cycle"><a href="#Life-Cycle" class="headerlink" title="Life Cycle"></a>Life Cycle</h4><ul>
<li>Transient</li>
<li>Scoped</li>
<li>Singleton</li>
</ul>
<h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><ul>
<li><p>MVC</p>
</li>
<li><p>WebAPI</p>
<ul>
<li>Restful</li>
</ul>
</li>
<li><p>RazorPages</p>
</li>
<li><p>SignalR</p>
</li>
</ul>
<h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><ul>
<li>DataProtection API</li>
<li>Authentication</li>
<li>Authorization</li>
<li>Token Service</li>
<li>Enviroment Variables</li>
</ul>
<h4 id="NETCore"><a href="#NETCore" class="headerlink" title=".NETCore"></a>.NETCore</h4><ul>
<li>Hosting</li>
<li>Servers</li>
<li>Http</li>
<li>Routing</li>
</ul>
<h4 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h4><ul>
<li>StaticFiles</li>
<li>WebSockets</li>
<li>HttpOverrides</li>
<li>HealthChecks</li>
<li>Rewrite</li>
<li>CORS</li>
</ul>
<h4 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h4><ul>
<li>DependencyInjection</li>
<li>Logging</li>
<li>Configuration</li>
<li>Options</li>
<li>Http</li>
<li>Hosting</li>
<li>Caching</li>
<li>Diagnostics</li>
<li>Localization</li>
</ul>
<h3 id="ASP-NET-Core生态组件"><a href="#ASP-NET-Core生态组件" class="headerlink" title="ASP.NET Core生态组件"></a>ASP.NET Core生态组件</h3><h4 id="Front-End"><a href="#Front-End" class="headerlink" title="Front End"></a>Front End</h4><ul>
<li><strong>Razor Pages</strong></li>
<li>Blazor</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul>
<li>AspectCore</li>
<li><strong>Autofac</strong></li>
</ul>
<h4 id="Object-Mapping"><a href="#Object-Mapping" class="headerlink" title="Object Mapping"></a>Object Mapping</h4><ul>
<li><strong>AutoMap</strong></li>
<li>Mapster</li>
</ul>
<h4 id="Job-Schedule"><a href="#Job-Schedule" class="headerlink" title="Job&amp;Schedule"></a>Job&amp;Schedule</h4><ul>
<li><strong>Hangfire</strong></li>
<li>Quartz</li>
</ul>
<h4 id="Authentication-Authorization"><a href="#Authentication-Authorization" class="headerlink" title="Authentication&amp;Authorization"></a>Authentication&amp;Authorization</h4><ul>
<li>ASP.NET Core Identity</li>
<li>IdentityServer4</li>
</ul>
<h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><ul>
<li><p><strong>EF Core</strong></p>
<ul>
<li><p>DbContext</p>
</li>
<li><p>Shadow Property</p>
</li>
<li><p>Code First代码优先</p>
</li>
<li><p>Configurations</p>
<ul>
<li>Data Annotation Attributes</li>
<li>Fluent API</li>
</ul>
</li>
<li><p>Fluent API</p>
<ul>
<li>One to Many Relationships</li>
<li>One to One Relationships</li>
<li>Many to Many Relationships</li>
</ul>
</li>
<li><p>数据迁移</p>
</li>
<li><p>实体更改跟踪</p>
</li>
<li><p>Data Loading</p>
<ul>
<li>Lazy Loading延迟加载</li>
<li>Eager Loading贪婪加载</li>
<li>Explic Loading显式加载</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Dapper</strong></p>
</li>
<li><p>SmartSql</p>
</li>
</ul>
<h4 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h4><ul>
<li><strong>FluentValidation</strong></li>
</ul>
<h4 id="Fault-Recovery"><a href="#Fault-Recovery" class="headerlink" title="Fault Recovery"></a>Fault Recovery</h4><ul>
<li><strong>Polly</strong></li>
</ul>
<h4 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h4><ul>
<li>ASP.NET Bollerplate Project(ABP)</li>
<li><strong>ABP VNext</strong></li>
</ul>
<h4 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h4><ul>
<li>Swagger</li>
</ul>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><ul>
<li><strong>gRPC</strong></li>
</ul>
<h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><ul>
<li><p>Framework</p>
<ul>
<li><strong>XUnit</strong></li>
<li>MSTest</li>
<li>NUnit</li>
</ul>
</li>
<li><p>Tools</p>
<ul>
<li><strong>Moq</strong></li>
</ul>
</li>
<li><p><a href="http://genfu.io/">GenFu</a>-use to generate realistic test data</p>
</li>
</ul>
<h4 id="Assertion-Tool"><a href="#Assertion-Tool" class="headerlink" title="Assertion Tool"></a>Assertion Tool</h4><ul>
<li>FluentAssertions</li>
<li><strong>Shouldly</strong></li>
</ul>
<h4 id="Integration-Testing"><a href="#Integration-Testing" class="headerlink" title="Integration Testing"></a>Integration Testing</h4><ul>
<li><strong>WebApplicationFactory</strong></li>
</ul>
<h4 id="API-Client"><a href="#API-Client" class="headerlink" title="API Client"></a>API Client</h4><ul>
<li><strong>PostMan</strong></li>
<li><strong>CURL</strong></li>
<li>Rest</li>
</ul>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><ul>
<li>Disconf</li>
<li><strong>Consul</strong></li>
</ul>
<h4 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h4><ul>
<li>MemoryCache</li>
<li><strong>Redis</strong></li>
<li>Memcached</li>
</ul>
<h4 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h4><h4 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h4><ul>
<li>Log4Net</li>
<li>ExceptionLess</li>
<li><strong>Serilog</strong></li>
</ul>
<h4 id="Log-management-system"><a href="#Log-management-system" class="headerlink" title="Log management system"></a>Log management system</h4><ul>
<li>Sentry.IO</li>
</ul>
<h4 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h4><ul>
<li><strong>Skywalking</strong></li>
</ul>
<h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><ul>
<li>SQL Server</li>
<li>MongoDB</li>
<li>Redis</li>
</ul>
<h4 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h4><ul>
<li>GraphQL-dotnet</li>
</ul>
<h4 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h4><ul>
<li>Elasticsearch</li>
<li>Solr</li>
</ul>
<h4 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h4><ul>
<li><strong>RabbitMQ</strong></li>
<li>Apache Kafka</li>
<li>ActiveMQ</li>
</ul>
<h4 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h4><ul>
<li><strong>Ocelot</strong></li>
</ul>
<h4 id="Big-Data"><a href="#Big-Data" class="headerlink" title="Big Data"></a>Big Data</h4><ul>
<li>Data Accelerator</li>
<li>.NET for Apache Spark</li>
</ul>
<h4 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h4><ul>
<li><strong>Nginx</strong></li>
<li>Envoy</li>
</ul>
<h4 id="Email-Send"><a href="#Email-Send" class="headerlink" title="Email Send"></a>Email Send</h4><ul>
<li>LumiSoft.Net</li>
</ul>
<h4 id="Performance-Analysis"><a href="#Performance-Analysis" class="headerlink" title="Performance Analysis"></a>Performance Analysis</h4><ul>
<li>MiniProfiler</li>
</ul>
<h4 id="Excel-Operation"><a href="#Excel-Operation" class="headerlink" title="Excel Operation"></a>Excel Operation</h4><ul>
<li><strong>EPPlus</strong></li>
</ul>
<h4 id="Other-Recommend"><a href="#Other-Recommend" class="headerlink" title="Other Recommend"></a>Other Recommend</h4><ul>
<li>MediatR</li>
<li>Swashbuckle</li>
<li>Benchmark.NET</li>
<li>NodaTime</li>
</ul>
<h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><ul>
<li>Controller</li>
<li>Validation</li>
<li>Mapping</li>
<li>Authentication</li>
<li>Authorization</li>
<li>Command Handler</li>
<li>Domain EventHandler</li>
<li>Integration EventHandler</li>
<li>Query Handler</li>
</ul>
<h4 id="DomainModel"><a href="#DomainModel" class="headerlink" title="DomainModel"></a>DomainModel</h4><ul>
<li>Aggregate</li>
<li>Entity</li>
<li>ValueObject</li>
<li>DomainEvent</li>
</ul>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><ul>
<li>Repository</li>
<li>UnitOfWork</li>
<li>DbContext</li>
<li>Transcation</li>
</ul>
<h4 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h4><ul>
<li>Config</li>
<li>EventBus</li>
<li>Caching</li>
<li>Logging</li>
<li>…</li>
</ul>
<h3 id="ABP架构思想"><a href="#ABP架构思想" class="headerlink" title="ABP架构思想"></a>ABP架构思想</h3><ul>
<li>Module模块化</li>
<li>工作单元</li>
<li>多租户</li>
<li>动态API</li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul>
<li><h5 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h5></li>
<li><h5 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h5></li>
<li><h5 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h5></li>
<li><h5 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h5></li>
<li><h5 id="服务跟踪"><a href="#服务跟踪" class="headerlink" title="服务跟踪"></a>服务跟踪</h5></li>
<li><h5 id="服务安全"><a href="#服务安全" class="headerlink" title="服务安全"></a>服务安全</h5></li>
<li><h5 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h5></li>
<li><h5 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h5></li>
<li><h5 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h5></li>
<li><h5 id="接口框架"><a href="#接口框架" class="headerlink" title="接口框架"></a>接口框架</h5></li>
<li><h5 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h5></li>
</ul>
<h3 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h3><h4 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h4><ul>
<li>单一责任原则(SRP)</li>
<li>开放封闭原则</li>
</ul>
<h4 id="编程范式与设计模式"><a href="#编程范式与设计模式" class="headerlink" title="编程范式与设计模式"></a>编程范式与设计模式</h4><p><a href="https://github.com/amerina/DesignPatternAndPrinciple">amerina&#x2F;DesignPatternAndPrinciple: 常见设计模式与设计原则</a></p>
<ul>
<li>CQRS</li>
<li>装饰模式</li>
<li>策略模式</li>
<li>观察者模式</li>
<li>建造者模式</li>
<li>单例模式</li>
<li>外观模式</li>
<li>中介者模式</li>
</ul>
<h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><h4 id="软件架构设计"><a href="#软件架构设计" class="headerlink" title="软件架构设计"></a>软件架构设计</h4><h4 id="整洁与重构"><a href="#整洁与重构" class="headerlink" title="整洁与重构"></a>整洁与重构</h4><h4 id="协作与项目管理"><a href="#协作与项目管理" class="headerlink" title="协作与项目管理"></a>协作与项目管理</h4><h3 id="个人知识体系"><a href="#个人知识体系" class="headerlink" title="个人知识体系"></a>个人知识体系</h3><h4 id="思维脑图"><a href="#思维脑图" class="headerlink" title="思维脑图"></a>思维脑图</h4><h4 id="学习路径-进阶指南"><a href="#学习路径-进阶指南" class="headerlink" title="学习路径&amp;进阶指南"></a>学习路径&amp;进阶指南</h4><h4 id="资源列表-书籍列表"><a href="#资源列表-书籍列表" class="headerlink" title="资源列表&amp;书籍列表"></a>资源列表&amp;书籍列表</h4><h4 id="速学速查手册"><a href="#速学速查手册" class="headerlink" title="速学速查手册"></a>速学速查手册</h4><h4 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h4>]]></content>
      <categories>
        <category>.NETCore</category>
      </categories>
      <tags>
        <tag>.NETCore</tag>
      </tags>
  </entry>
  <entry>
    <title>To Be YourSelf</title>
    <url>/2023/11/28/To%20Be%20YourSelf/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="追溯到知识的源头"><a href="#追溯到知识的源头" class="headerlink" title="追溯到知识的源头"></a>追溯到知识的源头</h3><ul>
<li>阅读各种资料、书籍、文章，只是让你懂得更多，并不会让你提高技能。只有通过练习（practice）才能提高技能。如果你想变得更好，那就去动手做。</li>
<li>去读书不要去读他人消化过的知识</li>
<li>重要的是在路上，重要的是，你不放手</li>
</ul>
<h3 id="理想就是财富的一部分"><a href="#理想就是财富的一部分" class="headerlink" title="理想就是财富的一部分"></a>理想就是财富的一部分</h3><ol>
<li>制定远大的目标</li>
<li>坚持去做真正有价值的事，哪怕这件事极少有人在做</li>
<li>找到人生的兴趣、激情、方向</li>
<li>找到使你快乐、有价值的事情，坚持去做</li>
</ol>
<h3 id="费曼技巧"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧</h3><p><strong>费曼技巧，总共分为四步：</strong></p>
<ol>
<li><p>选择一个你想要理解的概念：明确需要学习和理解的目标</p>
</li>
<li><p>设想一种场景，你正要向别人传授这个概念</p>
<p>想象一个场景或者拿一张白纸，就好像你正在教一位初次接触这个概念的学生一样，用简单的语言表达你的概念。在这个过程中，你会更清楚地意识到关于这个概念你理解了多少，以及是否还存在理解不清的地方。</p>
</li>
<li><p>如果你感觉卡壳了，就回顾一下学习资料</p>
<p>如果你感觉卡壳了，就要回到最初的学习资料并重新学习让你感到卡壳的部分，直到你领会顺畅，可以在纸上解释这个部分为止。</p>
</li>
<li><p>为了让你的讲解通俗易懂，请简化语言表达</p>
<p>用你自己的语言，而不是学习资料中的语言来解释概念。你要努力简化语言表达，或者与已有的知识建立一种类比关系，以便更好地理解它。</p>
</li>
</ol>
<p><strong>费曼技巧具体应用方式：</strong></p>
<ol>
<li>向不熟悉某议题的人解释该议题，用他们能理解的方式及最简单的语言向他们解释</li>
<li>发现自己不能理解的地方或不能简单解释某议题的地方并记录</li>
<li>回头查看资讯来源并研读自己薄弱的地方直到能用简单的语言来解释</li>
<li>重复前面三项步骤直到能够专精这个议题</li>
</ol>
<p><strong>费曼学习法的核心</strong>是——当你准备学习一门新知识时，必须站在传授者的立场，假设自己要向别人讲解这门知识。那么你一定要用最简洁、清晰和易于理解的语言表达出来，才能让行外的人也能听懂。</p>
<p>费曼说：“最好是几岁的小孩也能明白你在说什么。”为此，他制定了一个简单易行的流程：</p>
<ol>
<li>确立你要学习的目标。找到和列出自己想要了解的知识，可以是一本书，也可以是一门技术，甚至是你能想象到的任意领域和事物。</li>
<li>理解你要学习的对象。针对这个目标，准备好和筛选相关的资料，选择可靠和多个角度的信息来源，把这些内容系统化地归纳整理出来。</li>
<li>以教代学，用输出代替输入。模拟一个传授的场景，用自己的语言把这些知识讲给别人，用以检查自己是否已经掌握了这些知识。</li>
<li>进行回顾和反思。对其中遇到阻碍、模糊不清和有疑义的知识重新学习、回顾和反思。如有必要，可以重整旗鼓，进行再一次输出。</li>
<li>实现知识的简化和吸收。最后，通过针对性的简化和整合，实现这些知识的内化和有效的应用。</li>
</ol>
<p>在输出知识的过程中，你可以站在另一个“自我”的角度审视这些内容。那个“自我”是知识的讲解者，你由此获得了一个检验自身学习成果的机会。你要把学到的东西有逻辑、有结构地传达出来，看看它是否具有吸引力和传播力。</p>
<p>如果你自己和别人都没有听懂，也不觉得多么有用，那它怎能称得上是已经被学到的知识呢？知识的输出越多，我们对于陌生事物的联想就越丰富，学习的创新性就越强，最终成功地突破旧知识的框架，得出有价值的新知识。</p>
<p>费曼认为，输出不仅仅是学习的最佳方式，同时也是学习的终极目的——当我们要学习一种新知识时，用最直白的语言去阐述它时，大脑就会从记忆库中提取那些熟悉的信息，在旧的知识和新的概念中产生强大的关联，新的知识便容易得到大脑彻底的理解。</p>
<p>最重要的一步是，你要反复地进行这一过程，使大脑多进行创造性的联想，我们对新知识的吸收和应用的能力才会变得更强。</p>
<p><strong>费曼技巧扩展：</strong></p>
<ul>
<li><p>拆分问题：当你想了解一个复杂的知识点时，需要把它分而化之，切成小知识块，再逐个对付</p>
</li>
<li><p>压缩知识：一本书很厚，里面的信息容量很大，我们无法记住所有的内容。但聪明的人会把书本呈现的信息进行压缩，提炼出规律和知识，来达到和原有的知识体系产生联系。压缩知识的过程，也是理解和内化的过程。</p>
</li>
<li><p>他好像什么都懂了，做起来却一塌糊涂；他学了很多，又好像什么都没学会</p>
</li>
<li><p>验证你是否真正掌握一个知识，就在于看你能否用直白浅显的语言把复杂深奥的问题和知识讲清楚。</p>
</li>
<li><p>费曼说：“只有在运用知识去做事时你才会发现，这个知识点为何我没有印象？这时你才意识到自己并没有真正地理解所学的知识。”</p>
</li>
</ul>
<p>费曼曾经说：</p>
<ul>
<li>“我们为何学习呢？“</li>
<li>“知识对我们究竟意味着什么？“</li>
<li>“知识的本质又是什么？“</li>
</ul>
<p>解决了这三个问题，我们也就找到了人生的答案。无论我们去学习何种知识，都能把它融入我们的生活场景中，化作属于自己的力量。</p>
<p><a href="https://postimg.cc/RWfzyZ4S"><img src="https://i.postimg.cc/DwpyWSNX/Pyramid-learning-method.jpg" alt="Pyramid-learning-method.jpg"  /></a></p>
<h3 id="我对世界充满了疑惑"><a href="#我对世界充满了疑惑" class="headerlink" title="我对世界充满了疑惑"></a>我对世界充满了疑惑</h3><h4 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h4><ul>
<li><p>做一个真正的明白人，心中有墨水，心中有底气，然后无所畏惧，遇到什么瓶颈都不虚</p>
</li>
<li><p>要时常做自我总结、阶段性总结、一日三省吾身</p>
</li>
<li><p>收集、整理、思考、实践、分享</p>
</li>
<li><p>以前都是我们告诉你做什么，从现在开始，你必须自己回答这个问题了，我期待你来告诉我，什么事情需要做。</p>
</li>
<li><p>找到那些比你水平更高、更聪明的人，尽量和他们在一起，吃饭或者喝咖啡，向他们讨教，了解他们拥有的知识。你的职业，甚至你的生活，都会因此变得更好。</p>
</li>
<li><p>愿你找到属于自己的快乐，发现属于自己的星空</p>
</li>
<li><p>你是愿意就这样学点皮毛混口饭吃随波逐流，还是成为真正的开发业界顶尖技术大牛，推动业界的发展，去改变世界？</p>
</li>
<li><p>原来我并不是畏惧平庸，而是害怕天赋永不显露，害怕努力不得回报。可至少有人愿意与我同行，有人愿与在前指引，我也得以跌跌撞撞地一直前进。希望终有一天，我技能强大，内心强大</p>
</li>
<li><p>成长必须经历一个步骤，就是把知识内化成能力。知识是用脑记住的，能力是用手练习出来的。</p>
<p>在工作的几年里，我们可能看过很多书，听过很多技术讲座和视频，但是通过听和看只是让你能记住这些知识，这些知识还不能转换成你的能力。听和看只是第一步，更重要的是实践，通过刻意练习把听到和看到的知识内化成你的能力。刻意练习，就是有目的的练习，先规划好，再去练习。</p>
<p>首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：</p>
<ol>
<li>专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法</li>
<li>反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足</li>
<li>修正（Fix），改进自己的不足。如果你对现状不满意，那么你只能打自己两耳光，你之前的所有决定导致了你的现状。然后，开始做更好的选择。</li>
</ol>
<p>不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。<br><strong>首先要确定学习的知识领域，需要达成的学习目标，针对目标制定学习计划，就像你要写一本书一样，先把目录写出来，然后根据目录上的知识点逐步去学习，最后把这些知识点关联起来，形成一个系统化的知识体系。学习的时候，可以制定一个计划，以周为单位，比如第一周学什么，第二周学什么。</strong></p>
</li>
<li><p>“你的想法会大幅度影响你的行为。当你的大脑告诉你“做不了”，你却仍然选择行动，结果就会开始改变。”</p>
</li>
<li><p>年轻人最核心的能力是坚持长久的做一件事，比如坚持十年</p>
</li>
<li><p>人最核心的能力就是把自己能做到的事情做到位</p>
</li>
<li><p>所有人都想永远挑战自我，但实际生活中人们主要的时间都在做一些驾轻就熟的事情。</p>
</li>
<li><p>与天斗其乐无穷与地斗其乐无穷与人斗其乐无穷也</p>
</li>
</ul>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p>“有问题就会有答案”</p>
</li>
<li><p>找到属于自己的路</p>
</li>
<li><p>模仿是成长的捷径</p>
</li>
<li><p>所以你想要什么?</p>
</li>
<li><p>选择做困难的事情</p>
</li>
</ul>
<h4 id="梦想"><a href="#梦想" class="headerlink" title="梦想"></a>梦想</h4><ul>
<li>“只有有了梦想，确定了目标，你才有更大的积极性去学习”</li>
<li>只有梦想才能驱除迷茫。迷茫就像是一间黑暗的屋子，你光想着把黑暗扫出屋子，是永远做不到的。但当你在屋子里点亮一盏灯，哪怕只是很小的灯、很微弱的光，也能够让这个屋子不再黑暗。梦想就是这盏灯。</li>
<li>“要敢于做梦，只要有梦想，你的人生就会一步一步向上走。”</li>
<li>“成功者和失败者的区别就在于，失败者即使在没有困难的情况下也会对自己的工作感到厌烦，而成功者即使面对重重困难，但内心仍然愿意选择自己所从事的工作，他会享受这种奋斗甚至煎熬的整个过程，当战胜困难之后，他内心获得的快乐是无法用语言来表达的”</li>
<li>“永远不要说：不可能，而要问：如何才能做到？答案就隐藏在问题中，你把问题分析透彻以后，答案自然就会浮现了”</li>
</ul>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul>
<li>程序员没有必要局限在一种语言或工具。工具每天都在变化，只要新工具适合你的用例，就可以选择它。你的标准应该是，选择最能够快速有效地解决问题的任何语言或工具。</li>
<li>最终成为的是一个优秀的程序员还是一个很烂的程序员，这跟你的出身一点关系都没有。而真正的原因只有一个，唯一的一个：对你所做的事情的理解越深，你就会做的越好。</li>
<li>最好的程序员不是善于编写复杂代码，而是有能力为复杂的问题提出简单的解决方案。只有糟糕的程序员，才会对简单的问题提出复杂的解决方案。</li>
<li>有人会说，该知道的我都知道了。而对说这话的人的验证就是看他们能有应用他们知道的知识的能力。<ul>
<li>是否他能够构造出完美的系统架构，让人们能轻松的维护？</li>
<li>是否他能在不皱眉头的情况下把一个普通程序员毫无可能解决的问题轻松解决掉？</li>
<li>是否他能在被询问时能用最简单的概念把任何问题都阐述明白？</li>
<li>如果能够，那他就是一个杰出的程序员，他能很好的理解了他在做的事情。</li>
</ul>
</li>
<li>然而，尽管这些人看起来已经“无所不知”，很多的程序员(包括我)都感觉他们仍然在知识的海洋里奋斗不已。有如此多的东西需要去学习，一个人几乎要花费他毕生的心力去学习，但仍然很难说能掌握计算机知识的90%。</li>
<li><strong>而这场持久战中的秘密武器、战胜计算机知识的亚瑟王的神剑，就是透彻理解。</strong>对你的领域里的基础知识理解的越好，你就越容易提升到更高的层次。你对这一层次的知识理解的越好，你就更容易掌握下一层次，以此类推。一旦你从最简单最基础的知识走到最高级最复杂的理论，你可以从头再过一遍，此时你会惊奇的发现，在最低最底的底层，竟然还有那么多知识需要学习。</li>
<li>看起来这个道理实在是太简单，难以受到重视，但事实就是这样。<strong>通往杰出的程序员的道路就是完全的深入的理解，从掌握精通最基本的知识开始，从而逐渐牢固掌握更高级的知识。</strong></li>
<li>工作要用的事情就应该占用工作时间去研究，课余的时间当然是花在提高自己的元编程水平上：大概就是算法啊、架构啊、设计模式啊、单元测试啊各种任何语言都用得上的东西了。</li>
<li>超级程序员跟那些平庸的、一般的程序员比起来，对自己要做的事情的理解要深的多的多。这就是原因。要想成为一名出色的程序员，你所要做的就是完全的理解要在做的事情。</li>
<li>软件架构充满了妥协，是因为生活本身是复杂的，而生产资料是有限的。</li>
<li>新功能大部分人都可以写,但是解决问题的能力,或者说当你需要优化当前代码的时候就需要基础架构的能力。这个能力往往是新手不具备的，因为他们不会遇到这样的场景也不具备基础架构深入思考的能力。</li>
<li>全面的测试，良好的文档记录和可靠的自动化功能</li>
</ul>
<h3 id="高效学习策略"><a href="#高效学习策略" class="headerlink" title="高效学习策略"></a>高效学习策略</h3><h4 id="高效学习策略-1"><a href="#高效学习策略-1" class="headerlink" title="高效学习策略"></a>高效学习策略</h4><ol>
<li><p>重复：重复是通向精通的必由之路</p>
<p>我坚信重复是通向精通的必由之路。当我们学习一种新的技能，必须经常性地对这种技能加以练习。当我们学习一种新的知识或理论，也必须对尽可能多地对其加以应用。李小龙曾经讲过一句非常经典的名言，『我从不畏惧一个知道一万种踢法的人，但是我害怕一个把一种踢法练习过一万次的对手。<br>任何一种技能，只要经过连续不断地磨练和改进，最终效果都将变得异常惊人。</p>
</li>
<li><p>专注：专注的真正含义在于，当你同时面对几百个好想法时，你必须精挑细选。</p>
<p>现代生活中的干扰因素太多 - 社交媒体、多任务、开放式学习与办公环境 - 我们总是能不断地收到来自外部的各种刺激信号。我们已经丧失了专注的能力。然而专注是学习和掌握很多科目和专业必备的前提条件。<br>为了学习一种新的技能，我尽量让自己处于一个没有打扰的环境之中。当我阅读一些东西时，我会听一些没有歌词的纯音乐，这样的话，我的注意力就不会被分散了。<strong>史蒂夫·乔布斯说过，”人们通常认为专注意味着，对你正在做的事情说 Yes，实际上根本不是这样。专注的真正含义在于，当你同时面对几百个好想法时，你必须精挑细选。”</strong></p>
</li>
<li><p>背景与细节：不停地在细节和上下文之间来回切换</p>
<p>为了理解一门学科，我觉得首先你应该对这个学科的概貌有一个大致的了解。我自己就非常喜欢探求一些事物的背景以及来龙去脉。所以，我在阅读一本书之前，总是先浏览一下这本书的目录。这样我就对这本书的内容有了一个基本印象。当我阅读内容细节时，我将对内容中一个主题与另一个主题之间的关系就更加清晰了。细节非常重要，但是要在合适的时机。<strong>过早地开始关注细节，你很可能错失上下文或整体信息。当然，错失了细节，也会让你的理解仅仅停留在一些事物的表面。</strong>所以，我会不停地在细节和上下文之间来回切换。这样我就能够在获取知识或技能的整体性概念的同时，又能学到具体内容及细节。</p>
</li>
<li><p>关系：信息之间的关系</p>
<p>这种在上下文与细节之间来回切换的学习方式，向我充分展现了信息之间的关系。这一点对于学习与记忆的长期效果来说，非常非常重要。这就是为什么当我们谈论某一局牌时，有人能够绘声绘色地回忆起每一个细节。其实诀窍就在于牌与牌之间的关系。<strong>在不同主题之间构建一种有意义的关系或联系，就是加速学习和强化长期记忆的最有效手段。</strong></p>
</li>
<li><p>节奏</p>
<p>节奏是学习过程中最有趣的一个可变因素。例如，如果你正在听一场在线视频讲座，你可以加速这个讲座的播放速度（如以两倍速率播放）。</p>
<p>节奏还有一个重要功能。它能够让我们置身于完全不同的环境和压力之下。为了适应这种变换，我们自身会自发地调节相应的学习方法。刻意让自己体验这种不断变化的学习节奏，能够更好地强化我们的学习效果和学习能力。长跑运动员训练冲刺式的速跑，就是为了磨练自己对不同状况路面的适应性。就我个人而言，如果我正在准备一场演讲或者技术演示，我会在最后一次练习中以两倍语速讲话。这样做就是为了确保，在我面临外部压力之下（公开场合演示），可以记起所有的演讲内容和信息。如果在语速加倍的情况下，我都能回忆起这些信息，我自然能在正常语速下，轻松地想起这些内容。变换节奏不只是与回忆或记忆相关，其实这样做在很大程度上，能够激发和改变学习的潜能和活力 - 为你的学习工具箱添加一个灵活的新工具。</p>
</li>
</ol>
<h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><p><strong>刻意练习，就是有目的的练习，先规划好，再去练习。</strong></p>
<p>在工作的几年里，我们可能看过很多书，听过很多技术讲座和视频，但是通过听和看只是让你能记住这些知识，这些知识还不能转换成你的能力。</p>
<p><strong>听和看只是第一步，更重要的是实践，通过刻意练习把听到和看到的知识内化成你的能力。刻意练习，就是有目的的练习，先规划好，再去练习。</strong></p>
<p>首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：</p>
<ol>
<li>专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法</li>
<li>反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足</li>
<li>修正（Fix），改进自己的不足。不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性</li>
</ol>
<p><strong>首先要确定学习的知识领域，需要达成的学习目标，针对目标制定学习计划，就像你要写一本书一样，先把目录写出来，然后根据目录上的知识点逐步去学习，最后把这些知识点关联起来，形成一个系统化的知识体系。</strong>学习的时候，可以制定一个计划，以周为单位，比如第一周学什么，第二周学什么。</p>
<p>成长必须经历一个步骤，就是把知识内化成能力。知识是用脑记住的，能力是用手练习出来的。</p>
<h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><p>番茄工作法的关键是：规划，追踪，记录，处理，以及可视化。</p>
<ul>
<li>在规划阶段，任务被根据优先级排入”To Do Today” list。 这允许用户预计每个任务的工作量。</li>
<li>当每个番茄时结束后，成果会被记录下来以提高参与者的成就感并为未来的自我观察和改进提供原始数据。</li>
<li>番茄时意指每个工作时段的时长。当任务完成后，所有番茄计时器剩下的时间会被用于过度学习。</li>
<li>短休息时间可以辅助达到心理学上的同化作用，3-5分钟的短休息间隔开每个番茄工作时段。</li>
<li>四个番茄工作时组成一组。一个15-50分钟的长休息间隔开每组作业。</li>
<li>这一时间管理技术的本质目的是减少内生和外在的干扰对意识流的影响。一个单位的番茄工作时不可再细分。</li>
<li>当在番茄工作时中被打断的情况下，只可能有两种情况：干扰的活动被推迟（告知 - 协商 - 安排日程 - 回访），或者当前的番茄工作时废弃，必须重新开始。</li>
</ul>
<p><strong>具体实践：</strong></p>
<ol>
<li>决定待完成的任务</li>
<li>设定番茄工作法定时器至 n 分钟（通常为25分钟）</li>
<li>持续工作直至定时器提示,记下一个番茄</li>
<li>短暂休息3-5分钟</li>
<li>每四个番茄，休息15-30分钟</li>
</ol>
<h4 id="技术的学习与练习"><a href="#技术的学习与练习" class="headerlink" title="技术的学习与练习"></a>技术的学习与练习</h4><p>练习式学习。我的模式比较固定，一般是就是这么几步：</p>
<ol>
<li>实践一些新的技术和概念（要比其它人快半步）</li>
<li>抽取这些技术和概念，造建一个新的轮子</li>
<li>把造轮子、实践的过程写成文章</li>
<li>系统性的把这些文章整理成电子书</li>
<li>先无脑地输入，再总结、思考输出，最后系统性整理。</li>
</ol>
<h3 id="没有规划就没有效率"><a href="#没有规划就没有效率" class="headerlink" title="没有规划就没有效率"></a>没有规划就没有效率</h3><ol>
<li><p>第一个现实是，人人都有选择权</p>
</li>
<li><p>第二个现实是，只有少数几件事，是重要的</p>
<p>透过现象看本质思维。花半秒钟就看透事物本质的人，和花一辈子都看不清事物本质的人，注定是截然不同的命运</p>
</li>
<li><p>第三个现实是，没有规划就没有效率</p>
<ul>
<li>“简洁思维”就是做出“更少，但更好”的选择，通过合理规划，高效到达目标。</li>
<li>以终为始思维。就是搞明白你究竟要的是什么，然后再反过来倒推具体的行动步骤。</li>
<li>即时反馈思维。有一种很有效的学习方法叫“费曼技巧”。通俗的说，就是将你刚刚学到的东西，用大白话的形式讲给别人听，如果能讲清楚，那么说明真的理解了。而费曼的过程就是不断地给自己创造即时反馈的过程。<strong>一个人做需要长期坚持的事情，都是需要去给自己正向反馈的。</strong></li>
</ul>
</li>
<li><p>成为有目标的学习者</p>
</li>
<li><p>编程能力</p>
<ul>
<li>好书读多了 你就明白：技术是一环扣一环的，有牢固的技术知识体系，学啥都事半功倍。 </li>
<li>源码看多了 你就明白：自己的查克拉莫名的增多了。而且吐槽文档不全的习惯也渐渐少了，一个不服就跑去观摩别 人的源码，顺便偷个师。<br>再往后，或许你的技术确实突飞猛进了，然而你却只会觉得编程本来就是这个样子的。 因为，<strong>但凡通过点滴付出，累积出来的结果，都是平淡无声的。</strong></li>
<li>有目的的练习，尤其是一个完整的应用问题的解决，是学习的不二法门。学习系统设计的最佳途径是看一个优秀设计的源码，检验成果的方式是改造它应用于你的实际场景。</li>
</ul>
</li>
</ol>
<h3 id="多周目知识树学习法"><a href="#多周目知识树学习法" class="headerlink" title="多周目知识树学习法"></a>多周目知识树学习法</h3><p>先说多周目，周目就是轮次的意思，经常玩游戏的同学应该会知道，很多剧情都要二周目甚至三周目才能玩出来。这里借用的就是这个概念。作为初学者，我们不奢求一次吃个胖子，我们分多次来学习。</p>
<ol>
<li><p>第一遍看全局，知道有哪些东西，每一部分都是干什么用的，哪些重要，哪些不重要。</p>
</li>
<li><p>第二遍重原理，从最核心的原理出发，一步一步尝试以最短的路径走通整个流程，完成核心任务。</p>
</li>
<li><p>第三遍补周边，把之前做的方案拿出来，看看哪些地方可以优化，哪些地方能做得更好。这么几遍下来，每次的学习难度降低了不少，而我们对知识的理解却深入了很多。</p>
</li>
<li><p>然后是知识树。就像前文所说，知识点并不是平等的。我们需要在理解本质和原理的基础上，梳理出一颗知识树。在这棵树上，我们应该可以清晰的看到哪些知识是核心、那些知识是周边，我们为什么要学它、学了它能用到那些地方。</p>
<p>每个人的知识树可能不一样，会随着你的理解进行调整。初学者往往很难立马建立起来完整的知识树，这时候可以借助一些学习路线图作为样本。</p>
</li>
</ol>
<h3 id="努力是没有用到的"><a href="#努力是没有用到的" class="headerlink" title="努力是没有用到的"></a>努力是没有用到的</h3><ul>
<li>人生就像走阶梯，每一阶有一阶的难点。成功的人生是台阶式向上，而不是一条水平线。努力只是说明你拼命在走，跟你能不能向上走关系不大。那些努力却没有结果的人，根本原因就在于他一直走在平面上，没有走到更高的台阶。</li>
<li>垂直方向的努力更有意义，水平方向的努力意义不大。</li>
</ul>
<h3 id="什么才是你的核心竞争力"><a href="#什么才是你的核心竞争力" class="headerlink" title="什么才是你的核心竞争力"></a>什么才是你的核心竞争力</h3><ul>
<li><p>知道自己在做什么。几年后自己能达到什么样的程度</p>
</li>
<li><p>95%的程序员都是平均水准。你所接触到的优秀程序员能够做到的，你也可以做到</p>
</li>
<li><p>人才作为资源的一种，也是同样的道理。而稀缺性，换种说法也可以叫做不可替代性。一种资源越是稀缺，不可替代性就越强</p>
</li>
<li><p>以下的知识技能组合是具有相当程度的不可替代性的</p>
<ol>
<li>专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。</li>
<li>跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind ，等等。</li>
<li>学习能力：严格来说，学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。</li>
<li>性格要素：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等</li>
</ol>
</li>
<li><p>知识组合：</p>
<p>管理知识组合与管理金融组合非常相似：</p>
<ol>
<li>认真的投资者定期投资是–作为一种习惯。</li>
<li>多样化是长期成功的关键。</li>
<li>聪明的投资者在保守投资和高风险、高回报投资之间保持平衡。</li>
<li>投资者试图低买高卖以获得最大回报。</li>
<li>投资组合应定期审查和重新平衡。</li>
</ol>
<p>目标：既然你已经有了一些关于添加什么以及何时到你的知识投资组合的指导方针，那么什么是获得知识的最佳方式来为你的投资组合提供资金呢？这里有一些建议。</p>
<ul>
<li>每年至少学习一门新语言</li>
</ul>
<p>  不同的语言解决相同的问题会有不同的方式。</p>
<p>  通过学习几种不同的方法，可以帮助你拓宽你的思路，避免陷入陈规。此外，由于有大量的免费软件，学习许多语言是很容易的。</p>
<ul>
<li><p>每个月看一本技术书</p>
<p>虽然网上有大量的短文，偶尔也有可靠的答案，但要深入理解，你需要长文书。浏览书商，寻找与当前项目相关的有趣主题的技术书籍。</p>
<p>一旦养成习惯，每月读一本书。在你掌握了你目前正在使用的技术之后，分门别类地研究一些与你的项目无关的技术。</p>
</li>
<li><p>阅读非技术类的书</p>
<p>重要的是记住，计算机是由那些你试图满足其需求的人使用的。</p>
<p>你和别人一起工作，被别人雇佣，被别人攻击。别忘了人性里平等的一面，因为这需要完全不同的技能集（我们讽刺地称之为软技能，但它们实际上很难掌握）。</p>
</li>
<li><p>上课</p>
<p>在当地大学或在线学院，或在附近的贸易展览或会议上寻找有趣的课程</p>
</li>
<li><p>参加本地用户组和聚会</p>
<p>不要只是去听，而是积极参与。与世隔绝对你的职业生涯是致命的；找出你公司以外的人在做什么。</p>
</li>
<li><p>试验不同环境</p>
<p>如果你只在 Windows 系统工作，花点时间在 Linux 上，</p>
<p>如果您只使用 makefile 和编辑器，请尝试使用具有高端功能的复杂IDE，反之亦然。</p>
</li>
<li><p>保持自我更新</p>
</li>
</ul>
<p>  在网上阅读与当前项目不同的技术新闻和帖子。这是一个很好的方法，可以发现其他人对它有什么体验，他们使用的特定术语等等</p>
<p>  继续投资很重要。一旦你对新语言或新技术感到满意，就继续吧。再学一个。</p>
<p>  不管你是否在一个项目中使用过这些技术，甚至是否你把它们写在简历上。</p>
<p>  学习的过程会扩展你的思维，为你打开新的可能性和新的做事方式。</p>
<p>  异花授粉的想法是很重要的；尝试把你学到的经验应用到你当前的项目中。即使你的项目不使用这种技术，也许你可以借用一些想法。</p>
<p>  例如，熟悉对象定向，您将以不同的方式编写过程程序。理解函数式编程范式，您将以不同的方式编写面向对象的代码，依此类推。</p>
<ul>
<li>不要让问题停在那儿。 把它当作个人的挑战来寻找答案</li>
</ul>
</li>
<li><p>成长：</p>
<ul>
<li><p>认知：要在认知上超过别人，就要在下面几个方面上做足功夫</p>
<ul>
<li><p>信息渠道：信息的源头</p>
<p>试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。(比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？)</p>
</li>
<li><p>信息质量</p>
<p>信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，</p>
<p>我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。</p>
<p>所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p>
</li>
<li><p>信息密度</p>
<p>优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，</p>
<ol>
<li>搜索并学习其关联的知识</li>
<li>沉思和反省</li>
<li>亲手去推理、验证和实践……</li>
</ol>
<p>一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++&#x2F;Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章</p>
</li>
</ul>
</li>
<li><p>知识：要在知识上超过别人，你就需要在下面几个方面上做足功夫</p>
<ul>
<li><p>知识树（图）</p>
<p>任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。</p>
<p>而我们都知道，对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</p>
</li>
<li><p>知识缘由</p>
<p>任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。</p>
<p>靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</p>
</li>
<li><p>方法套路</p>
<p>学习不是为了找到答案，而是找到方法。</p>
<p>就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。</p>
<p>你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。</p>
</li>
</ul>
</li>
<li><p>技能：要在技能上超过别人，你就需要在下面几个方面做足功夫</p>
<ul>
<li><p>精益求精</p>
<p>如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p>
</li>
<li><p>让自己犯错</p>
<p>犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。</p>
<p>尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p>
</li>
<li><p>找高手切磋</p>
<p>下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p>
</li>
</ul>
</li>
<li><p>领导力</p>
<p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p>
<ul>
<li><p>识别自己的特长和天赋</p>
<p>首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），</p>
<p>如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。</p>
<p>那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。</p>
<p>你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p>
</li>
<li><p>识别自己的兴趣和事业：要有职业也要有事业</p>
<p>没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，</p>
<p>一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，</p>
<p>真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，<br>是那种无论有多大困难有多难受你都要死磕的事，<br>这才是“真∙兴趣”，</p>
<p>这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p>
</li>
<li><p>建立高级的习惯和方法</p>
<p>没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。</p>
<p>对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，<br>每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。</p>
<p>除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，</p>
<p>还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p>
</li>
<li><p>勤奋努力执着坚持</p>
<p>如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），</p>
<p>我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，</p>
<p>耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="财务管理"><a href="#财务管理" class="headerlink" title="财务管理"></a>财务管理</h3><ul>
<li>用生产者的视角看待世界，去看消费者需要什么——消费者是需要被满足的大多数人。</li>
<li>慢车道的核心是工作，快车道的核心是生意</li>
<li>快车道<ul>
<li>解密快车道的财富公式：财富 &#x3D; 净收益 + 资产价值，如何使人致富。</li>
<li>净收益 &#x3D; 销量 x 单元净收益；资产价值 &#x3D; 净收益 x 行业系数。</li>
<li>快车道生意的关键是销量！它必须是潜力巨大且增长迅速的，最好能呈指数级爆炸增长，这个取决于你的产品&#x2F;服务的市场。</li>
<li>快车道人们的资产是增值的，生意、品牌、知识产权、商业模式、不动产等。</li>
</ul>
</li>
<li>慢车道<ul>
<li>慢车道人们的资产是消费品，汽车、电子产品、珠宝、时装、包包等，这种资产从购买之日开始就是贬值的</li>
<li>慢车道的财富公式：财富 &#x3D; 工作薪水 + 理财收益</li>
</ul>
</li>
<li>“影响力法则”：影响越多的人，就可以赚更多的钱。</li>
<li>富人们也不是不消费，只不过顺序应该是：先做一个生产者，然后做一个消费者。可大多数人本末倒置，只看到了消费。</li>
</ul>
<h3 id="打造自己的产品"><a href="#打造自己的产品" class="headerlink" title="打造自己的产品"></a>打造自己的产品</h3><ul>
<li><p>首先，拥抱对方的产品种类，进入对方的市场</p>
<p>拥抱阶段 ：开发与竞争产品基本兼容的软件，或实施公共标准</p>
</li>
<li><p>然后，使用自己的专有功能扩展产品标准</p>
<p>扩展阶段：添加和推广竞争对手或标准不支持的功能</p>
</li>
<li><p>最后，利用这些差异，使竞争对手处于不利地位</p>
<p>扑灭阶段：由于市场份额的扩展，添加的功能成为事实上的标准时，再将竞争对手边缘化</p>
</li>
</ul>
<p>这是你的人生。</p>
<h3 id="如何构建自己的知识体系"><a href="#如何构建自己的知识体系" class="headerlink" title="如何构建自己的知识体系"></a>如何构建自己的知识体系</h3><p>知识体系是指某人不仅仅是指单一技术领域的能力，更重要的是有完整的系统性结构框架。</p>
<ul>
<li><p>技术层次</p>
<ul>
<li>0 – 对于相关的技术领域还不熟悉</li>
<li>1 – 可以读懂这个领域的基础知识</li>
<li>2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。</li>
<li>3 – 基本精通这个技术领域，完全不需要别人的帮助</li>
<li>4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。<ul>
<li>对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。</li>
<li>对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</li>
</ul>
</li>
<li>5 – 对于该技术领域有非常底层的了解和深入的技能。</li>
<li>6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构</li>
<li>7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。</li>
<li>8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</li>
<li>9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。</li>
<li>10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。</li>
</ul>
<p><strong>要想精通某一领域，你需要有坚实的基础，并基于此形成自己的知识体系。</strong>通过努力完善自身的技术，把基础打牢，这样你就可以解决任何问题。</p>
</li>
<li><p>技术基础</p>
<ul>
<li>程序语言：语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式…</li>
<li>系统原理：计算机系统，操作系统，网络协议，数据库原理…</li>
<li>中间件：消息队列，缓存系统，网关代理，调度系统 …</li>
<li>理论知识：算法和数据结构，数据库范式，网络七层模型，分布式系统…</li>
</ul>
</li>
</ul>
<h3 id="职业规划的长短期目标"><a href="#职业规划的长短期目标" class="headerlink" title="职业规划的长短期目标"></a>职业规划的长短期目标</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">--多与高人共处，勤与能人相伴</span><br><span class="line">Ask yourself: what you should do over the next ten or twenty years</span><br></pre></td></tr></table></figure>

<p>去求职网站看自己的职业岗位大公司有哪些要求，然后之后就专门往那些要求靠拢吧，该考证考证，该培养哪些能力就注重提升。</p>
<p>我觉得最难的还是找到自己的领域，一个愿意一辈子努力的领域，这个也没什么好说，我的经验是多去试，你不知道自己喜欢擅长什么，但总很容易发现自己讨厌的生活，排除那些你讨厌的，余下自己喜欢的。</p>
<h4 id="人生11问-长期规划-："><a href="#人生11问-长期规划-：" class="headerlink" title="人生11问(长期规划)："></a>人生11问(长期规划)：</h4><ol>
<li>你想做哪种类型的工作，自由的还是按照时间安排的？</li>
<li>你期待的年收入是多少？</li>
<li>你想住在什么样的房子里，和谁是邻居？</li>
<li>你想开什么样的车，怎么对待自己的交通时间？</li>
<li>你想穿什么品牌的衣服？</li>
<li>你希望别人如何看待你，如何称呼你？</li>
<li>你想如何帮助别人？</li>
<li>你想成为一个知识渊博的人吗？</li>
<li>你希望行走到哪些地方？</li>
<li>你怎样获得快乐和满足？</li>
<li>你会成为一个平衡工作，学习和生活的人吗？</li>
</ol>
<h4 id="人生7问-短期规划-："><a href="#人生7问-短期规划-：" class="headerlink" title="人生7问(短期规划)："></a>人生7问(短期规划)：</h4><ol>
<li>你现在的状态是否令自己满意？</li>
<li>满意的地方和原因是什么？</li>
<li>不满意的地方和原因是什么？</li>
<li>你要如何改变当前的状态？</li>
<li>你开始积累社会资源和人脉了吗？</li>
<li>你在做着一种平衡的工作吗？</li>
<li>你敢于对自己说真话、诚恳地直面真实的自己吗？</li>
</ol>
<h4 id="如何用8个步骤来制定职业规划："><a href="#如何用8个步骤来制定职业规划：" class="headerlink" title="如何用8个步骤来制定职业规划："></a><a href="https://www.indeed.com/career-advice">如何用8个步骤来制定职业规划</a>：</h4><ol>
<li><p>了解潜在的职业选择</p>
</li>
<li><p>发现不断增长的就业市场</p>
</li>
<li><p>确定适合你技能的职业</p>
</li>
<li><p>了解职业资格</p>
</li>
<li><p>评估工资和其他福利</p>
</li>
<li><p>比较可能的职业道路</p>
<p>在考虑了一些潜在的职业道路之后，比较一下你的选择。一个人可能需要更多的技能和额外的学位，与其他选择相比，这可能更费时或更昂贵。另一个可能有更高的潜在收入。</p>
<p>接下来，比较每条职业道路与你的核心价值观的匹配程度。一个可以让你发展出更多你渴望拥有的个人品质和人际关系。另一个可能会激励你创作出最好的专业作品。回顾一下你的利弊清单，评估一下哪条职业道路最有可能帮助你实现目标。</p>
</li>
<li><p>建立明智的目标</p>
<p>因为追求一条职业道路可能需要几年的时间，所以把更广泛的目标分成更小的你可以追踪的目标。尝试设定 SMART 目标来引导你完成这个过程:</p>
<ul>
<li>Specific具体: 使你的目标尽可能的精确。如果你渴望成为一名教师，设定一个明确的目标，比如在当地的学校系统中找到一份教高中生物的工作。</li>
<li>Measurable可衡量的: 量化你的进展。设定一些基准，比如完成学士学位或者申请10份符合你要求的工作。</li>
<li>Attainable可实现的: 设定你能够实现的目标。为了确认你的目标是可以实现的，想想每个步骤，并考虑它们有多现实。</li>
<li>Relevant相关: 你设定的任何与职业相关的目标都应该是真正重要的。想想这个目标有多重要，它是否能帮助你实现你的长期目标。</li>
<li>Time-based基于时间的: 给你的目标设定最后期限。</li>
</ul>
<p>如果你有一个特定的时间框架，你会更容易达到最终的结果，并激励自己去行动。</p>
</li>
<li><p>制定一份职业行动计划</p>
<p><strong>为你的职业生涯制作一张地图，回顾一下你的 SMART 目标中的行动项目，并列出你需要遵循的步骤。</strong></p>
<p>然后，把它们放在一张纸上或者电子日历上来建立你的日程表。随时准备好你的职业行动计划，这样你就可以定期回顾它。每完成一个步骤，都要检查一遍，并奖励自己大大小小的成就。根据需要重新审视和修改你的职业行动计划。新的机遇、技术进步、个人优先权和经济趋势都可能导致必要的职业规划变化。</p>
</li>
</ol>
<h4 id="为自己制定职业发展计划的五个步骤"><a href="#为自己制定职业发展计划的五个步骤" class="headerlink" title="为自己制定职业发展计划的五个步骤:"></a><a href="https://www.indeed.com/career-advice/career-development/steps-to-create-a-career-development-plan">为自己制定职业发展计划的五个步骤</a>:</h4><p>设定具体的、可衡量的职业发展目标可以帮助你进入职业生涯的下一个阶段。虽然制定一个职业规划需要大量的工作，但是它会帮助你了解你下一步的职业目标，以及你需要做些什么才能达到这个目标。创建和实施员工职业发展计划可以让你在工作中感到充满动力，即使你还没有找到理想的工作，因为它可以帮助你制定实现梦想的具体计划。</p>
<p>在这里，我们定义了一个职业发展计划模板，并概述了五个步骤，以轻松和有效地为自己制定一个个人发展计划：</p>
<ol>
<li><p>确定你现在的职位</p>
<p>任何职业发展计划的第一步都是确定你现在在职业生涯中的位置。这个步骤也可以让你反思自己目前的技能和优势。</p>
<p>在这个阶段，你应该考虑以下问题:</p>
<ul>
<li>我过去的经历是什么？</li>
<li>我喜欢做什么？</li>
<li>我有什么样的天赋和才能？</li>
<li>当我在工作中感到最兴奋或最有动力的时候，我在做什么？</li>
<li>我更喜欢领导一个团队，和同事一起工作还是单独工作？</li>
<li>什么让我充满活力? 什么消耗我的能量？</li>
<li>我在生活中有一个特定的使命吗？</li>
<li>是什么激励着我早上起床去上班？</li>
</ul>
<p>花点时间写下这些问题的答案。注意你目前在你所在领域的职位，包括你是否已经完成了你的教育，或者你是否想要追求更多的研究生教育，以及你在职业阶梯上的位置。</p>
</li>
<li><p>确定你的目的地</p>
<p>接下来，通过做以下事情来确定你职业生涯的方向：</p>
<ul>
<li>Brainstorm.头脑风暴<ul>
<li>抛开任何可能阻碍你前进的障碍或禁忌。你的理想职业是什么？</li>
<li>如果没有什么阻碍你前进的话，5到10年后你想去哪里？</li>
<li>包括你的终极职业目标。如果你的梦想是成为一家中型公司的首席执行官，那么就把它融入到你的计划中去。</li>
</ul>
</li>
<li>以简明扼要的表述形式制定更具体的目标<ul>
<li>确定你希望以较小的增量可以达到的位置是很有帮助的</li>
<li>考虑到你现在所处的位置和你所拥有的技能，你希望你的职业生涯在两年内走向何方？</li>
<li>这是一个与您当前日常生活足够接近的增量，因此其更容易可视化。</li>
</ul>
</li>
<li>接下来，想想你5到10年后想要达到的目标<ul>
<li>这是一个更实质性的步骤，需要你想象机会出现的情况下你所能够达到的目标</li>
<li>你是否想继续留在现在的公司，但是担任更高级的职位？</li>
<li>你想在另一家公司找到工作吗？或者，你可能想彻底转换职业。确保你的既定目标与最能激励你的事物相一致。</li>
</ul>
</li>
</ul>
<p>一旦你完成了这两个步骤，你应该对你的技能和你可以选择的职业有一个更好的了解。现在你已经准备好评估如何到达你的目标地点。</p>
</li>
<li><p>做差距分析</p>
<p>在这个阶段，您已经准备好进行差距分析，这将确定您现在的位置和您的目标位置。通过以下步骤完成差距分析:</p>
<ul>
<li><p>研究你的职业目标</p>
<p>以你列出的两年或五年的职业目标为重点，找到你想要的工作类型的工作列表。确保描述符合你的技能和经验，并且要求与你的最终目标一致。</p>
</li>
<li><p>咨询经验丰富的专业人士</p>
<p>此外，花时间咨询你的上司、导师和同事，了解是否有关键项目你应该添加到列表中。如果你的目标是在另一家公司找到一份薪水更高的工作，你可能不想告诉你的上司，但是你仍然可以向他们阐明你希望在现在的岗位上发挥的具体技能。</p>
<p>由于这种职业发展对你的团队、公司以及你个人都有好处，你的老板可能会很乐意帮助你联系资源或者分配相关的职责。</p>
</li>
<li><p>评估你的资历</p>
<p>一旦你收集了这些技能和经验，逐行排查，并根据要求对你目前的技能、教育和经验进行评估。创建一个1-5的简单评级系统，1表示您和需求之间没有匹配，5表示您完全满足要求。有了这个系统，评级越低，你需要投入更多的时间和精力来改进。</p>
</li>
<li><p>找出差距并确定模式</p>
<p>一旦您完成了这个练习，确定所有存在开发差距的领域。寻找共同的技能和经验，并把它们放在一起。你可能会开始注意到一些模式，其中哪些技能或经验你有扎实的背景，哪些需要进一步的发展。看看是否有需要按照特定顺序发生的项目。例如，在你承担与一个特定软件相关的额外工作任务之前，你需要学习如何使用它。这是你需要关注的技能、教育和经验的列表。</p>
</li>
</ul>
</li>
<li><p>制定你的职业发展计划</p>
<p>既然你已经掌握了职业生涯发展所需的技能细节，那么你就可以为此制定计划了。这一步包括列出你在未来几年想要获得的技能、教育和经验，并制定一个实现职业目标的具体计划。下面是要做的：</p>
<ul>
<li><p>设定以任务为导向的小目标</p>
<p>创建一组与列表中的每个项目相关的任务，这些任务将帮助您完成这些任务。例如，如果你想学习的技能之一是如何使用一个特定的软件，你的计划可以包括报名参加一个课程来学习它，与同事一起练习，并要求你的上司允许你使用这个软件作为你工作的一部分。</p>
</li>
<li><p>用时间表进行组织</p>
<p>根据你目标的逻辑轨迹，像时间表一样排列计划。从你可以相对快速地完成的短期目标开始，比如读一本书，然后再转向更长期的目标，比如获得硕士学位。</p>
</li>
<li><p>Think SMART</p>
<p>使用 SMART 目标模板可以帮助你设定可实现的目标。SMART 代表具体、可衡量、可实现、相关和有时限。例如，通过与你的主管一对一的工作来提高你对公司工资系统的理解的目标构成了 SMART 目标。按照 SMART 模板设计你的目标有助于确保你的目标是切实可行的，并且能够在预先设定的时间内实现。</p>
</li>
<li><p>创建任务截止日期</p>
<p>让自己对计划负责的最好方法是为每个任务分配日期。给自己一个“开始”的日期，你应该在这个日期之前完成一项任务。确保计划好每个项目的初步步骤。例如，在你参加专业发展课程之前，你可能需要申请并购买所需的教科书。在这个阶段，你有一个职业发展计划。</p>
</li>
</ul>
</li>
<li><p>衡量你的进步，准备好重新评估</p>
<p>你的职业发展计划并不会因为你创建了它而终止，现在实施阶段从以下几个步骤开始：</p>
<ul>
<li><p>保持跟踪</p>
<p>为了保持自己的责任感，跟踪你的实际执行是如何与第四步中给自己分配的日期保持一致的。每年至少检查两次这个列表，以确保你继续完成设定的时间表。</p>
</li>
<li><p>考虑里程碑</p>
<p>一旦你开始处理你的技能、教育和经验的列表，你就会想知道如何衡量你职业生涯的进步。一个积极的业绩评估，找到一份新工作，获得晋升，建立有用的职业关系或者获得奖励，这些都是衡量职业成功的标准。</p>
</li>
<li><p>相应地更新目标</p>
<p>意想不到的事情和事件将会发生。一个工作机会可能会让你的职业生涯朝着一个令人惊讶的方向发展，或者你可能会跨越整个国家。各种各样的因素可能会使你的计划偏离轨道。记住，只要你能保持灵活性，改变方向是可以的。这个计划并不具体，定期回顾一下是很有用的，可以更新你的目标以适应你的生活环境。除了定期跟踪你的进度，计划每六个月左右重新评估计划本身，并调整它以满足你当前的目标。</p>
</li>
</ul>
</li>
</ol>
<h3 id="如何快速地成长"><a href="#如何快速地成长" class="headerlink" title="如何快速地成长"></a>如何快速地成长</h3><h4 id="如何最快速的成长"><a href="#如何最快速的成长" class="headerlink" title="如何最快速的成长?"></a>如何最快速的成长?</h4><p>如何最快速的从初级到高级？区别明确了，问题就好办了！</p>
<ol>
<li>争取做自己不熟悉、不会做的；——不熟悉的熟悉了，不会做的会做了，自然就成长了</li>
<li>多做自己不熟练的、有难度的；——不熟练的熟练了，有难度的变得轻松了，自然就进步了</li>
<li>习以为常的操作，多考虑一下是否能够换个方式做得更快、更好、更省(自己琢磨也好，参考业内高手也行)</li>
<li>可以的话，思考一下如何让门外汉或初级员工更方便的做这个事情</li>
<li>尝试解决那些大家都解决不了的甚至被认为根本不可能解决的问题s</li>
</ol>
<h4 id="如何面试考察对方的级别"><a href="#如何面试考察对方的级别" class="headerlink" title="如何面试考察对方的级别?"></a>如何面试考察对方的级别?</h4><ol>
<li>你做过这个事情么？（或者：简历里你印象最深刻的事情是哪个？）</li>
<li>做的过程中遇到过什么问题？</li>
<li>你是如何解决这些遇到的问题（或者其它一些奇葩的问题）的？</li>
<li>类似的事情重新让你做的话，大概需要多久？</li>
<li>你们做过的这些工作，都有哪些地方可以继续改善提升的？</li>
<li>业内的通常做法是怎样的？为什么？有没有更好的方案？</li>
</ol>
<h4 id="你可以在工作中学到的6项重要工作技能"><a href="#你可以在工作中学到的6项重要工作技能" class="headerlink" title="你可以在工作中学到的6项重要工作技能"></a><a href="https://www.indeed.com/career-advice/career-development/learn-job-skills">你可以在工作中学到的6项重要工作技能</a></h4><p>最有抱负和最成功的人都有一种成长心态，不断寻找机会发展他们的工作技能。</p>
<p>许多人通过教育和认证课程学习各种技能，但是有几种技能是你可以在工作中获得的。</p>
<p>根据你的个人学习风格，在工作中掌握技能可以帮助你迅速提升你的职业生涯。</p>
<h5 id="在工作中学习技能意味着什么？"><a href="#在工作中学习技能意味着什么？" class="headerlink" title="在工作中学习技能意味着什么？"></a>在工作中学习技能意味着什么？</h5><p>在工作中学习技能是指通过在工作中完成任务来学习一种能力或发展知识。</p>
<p>大多数人在入职过程中会学到一些技能，而其他人则需要在特定工作的技术技能方面接受广泛的培训。</p>
<p>你可以在工作中通过实践一项任务、跟踪他人或利用职业发展机会来学习技能。</p>
<p>虽然你可能有一个特定的技能目标，你想学习在工作中，许多人发展他们的技能在工作中简单地通过完成他们的工作，并寻找方法，他们可以提高他们的职位。</p>
<h5 id="6个重要的工作技能："><a href="#6个重要的工作技能：" class="headerlink" title="6个重要的工作技能："></a>6个重要的工作技能：</h5><p>学习工作技能是适应许多不同行业的新工作环境的一个重要部分。</p>
<p>虽然有些技能是针对特定的职位或领域的，但许多不同的行业提供一些相同技能组合的在职培训。</p>
<p>以下是一些通常在工作中培养的技能：</p>
<ul>
<li>Industry or product knowledge 行业或产品知识</li>
<li>Professionalism 专业精神</li>
<li>Leadership 领导能力</li>
<li>Customer service 客户服务</li>
<li>Time management 时间管理</li>
<li>Strategic thinking 战略思维</li>
</ul>
<h5 id="如何在工作中学习工作技能？"><a href="#如何在工作中学习工作技能？" class="headerlink" title="如何在工作中学习工作技能？"></a>如何在工作中学习工作技能？</h5><p>在工作中学习技能可以显示你对工作的主动性和承诺，这可以增加你的职业机会。虽然大多数工作都会提供学习新技能的机会，但是决定如何开始可能是一个挑战。您需要采取的具体行动将取决于您的工作场所，但有一些技术适用于许多不同的环境。</p>
<p>使用这些方法开始在工作中学习新技能：</p>
<ol>
<li><p>Look for opportunities 寻找机会</p>
<p>获得工作技能最重要的步骤之一就是寻找成长的机会。在寻找新工作时，考虑选择一个强调在工作场所内进行培训的工作场所。</p>
<p>许多组织提供专业发展课程或其他免费培训的人谁是有兴趣提高他们的技能。你可以通过询问你的经理或者联系你雇主的人力资源部门来找到学习工作技能的机会。</p>
</li>
<li><p>Assess your skills 评估你的技能</p>
<p>在你专注于学习一项新技能之前，了解你在各种技能方面的经验水平是有帮助的。</p>
<p>的确，评估是衡量你在特定领域的知识和能力的一个很好的选择。</p>
<p>如果你有动力去追求一条需要技术技能的特定职业道路，你可以根据你所在行业的具体情况进行评估。</p>
<p>了解自己的优势和需要改进的地方将有助于你知道在工作中应该集中发展哪些技能。</p>
</li>
<li><p>Practice 练习</p>
<p>一旦你选择了一项要专注的技能，试着每天练习。</p>
<p>你在日常工作中练习的技能越多，你的专业技能发展得越快。</p>
<p>如果可能的话，开始在不会影响你工作整体质量的低风险情况下练习你的技能。</p>
</li>
<li><p>Learn from others 向别人学习</p>
<p>当你在工作中学习一项技能时，提高你能力的最好方法之一就是向那些在这个领域已经非常熟练的人学习。</p>
<p>如果你有一个特别擅长某项技能的同事，你可以要求跟随他们或者召开会议讨论他们的成功策略。</p>
<p>你也可以让他们观察你是如何完成一项技能或任务的，并向他们征求如何提高的建议。</p>
<p>当你发展你的工作技能时，试着向许多不同的同事学习，以便找到一种最适合你的技能。</p>
</li>
<li><p>Ask for feedback 寻求反馈</p>
<p>除了和同事一起工作，你还可以通过定期向你的经理和任何你经常合作的人寻求反馈来学习工作技能。你的队友可以就他们如何在工作中学习技能提供有价值的建议，并可能指导你获得有用的资源和培训机会。在寻求反馈时，要有礼貌，并接受别人告诉你的，以便专注于提高。</p>
</li>
<li><p>Track your progress 跟踪你的进度</p>
<p>当你开发你的技能时，通过定期的评估和比较你现有的知识和能力与你最初的技能水平来追踪你的进步。</p>
<p>这可以帮助你保持动力，并在必要时调整你的学习策略。</p>
</li>
</ol>
<h5 id="在工作中学习技能的步骤："><a href="#在工作中学习技能的步骤：" class="headerlink" title="在工作中学习技能的步骤："></a>在工作中学习技能的步骤：</h5><p>在工作中学习技能可以帮助你提升你的职业生涯，使你的简历对未来的雇主更具吸引力。</p>
<p>当你在工作中学习技能的过程中，请记住以下步骤，以便最大限度地利用你的经验：</p>
<ol>
<li><p>明确你的目标</p>
<p>考虑一下你为什么想要在工作中发展技能并且专注于你的目标。<br>通过一次只关注一种能力，你可以更有效地学习技能。</p>
</li>
<li><p>找一个良师益友</p>
<p>通过定期与人见面，讨论你的进展并提供指导，你可以更快地学习技能。<br>这也有助于确保您使用最佳行业实践正确地执行任务。</p>
</li>
<li><p>制定策略</p>
<p>根据可用资源创建学习每项技能的策略。<br>设定目标和期望可以帮助你衡量你的进步。</p>
</li>
<li><p>挑战自己</p>
<p>一旦你开始成功地在工作中运用你的新技能，通过寻找新的挑战继续提高你的技能。<br>这表明了你的雄心壮志，并且经常能让你在工作中成为一个非常有价值的人。</p>
</li>
</ol>
<p>Continue…Add Later</p>
]]></content>
      <categories>
        <category>Goal</category>
      </categories>
      <tags>
        <tag>Goal</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLServer Locking and Concurrency</title>
    <url>/2023/12/01/SQLServer%20Locking%20and%20Concurrency/</url>
    <content><![CDATA[<h3 id="并发控制模型"><a href="#并发控制模型" class="headerlink" title="并发控制模型"></a>并发控制模型</h3><p>一般数据库系统使用两种方式来管理并发数据访问：</p>
<ul>
<li>悲观并发控制</li>
<li>乐观并发控制</li>
</ul>
<p>对于任何一种并发控制模型，如果两个进程试图在同一时刻修改同一数据的话都会产生冲突。这两种模型之间的区别在于，<strong>是在冲突发生前进行防止，还是在发生后采用某种方法来处理冲突。</strong></p>
<ol>
<li><p>悲观并发控制</p>
<p>对于悲观并发控制，SQL Server 的默认行为是获取锁（lock）来阻塞对于别的进程正在使用的数据的访问。悲观并发模型假定系统中存在足够多的数据修改操作以致任何确定的读操作都可能会受到由别的用户所制造的数据修改的影响。换言之，数据库系统具有悲观的行为并且假定冲突是会发生的。悲观并发控制是通过占有( acquirc）正在被读取的数据上的锁来避免冲突的，囚此其他进程都无法修改该数据。同样地，占有正被修改的数据上的锁会造成其他进程都无法访问数据（无论是读取还是修改）。换句话说，<strong>在悲观并发环境中，读者（reader）和写者( writer）之间是会互相阻塞的。</strong></p>
</li>
<li><p>乐观并发控制</p>
<p>乐观并发模型假定系统中存在非常少的相冲突的数据修改操作，以致任何单独的事务都不太可能修改其他事务正在修改的数据。<strong>乐观并发控制的默认行为是采用行版本控制使数据读者能够看到修改操作发生以前的数据状态。旧版本的数据行会被保存下来，因此一个读取数据的进程可以看到在该进程刚开始进行读取时的数据并且不会受到任何正对该数据进行修改操作的影响。</strong>一个修改数据的进程不会受到其他正在读取该数据的进程的影响是由于读者正在访问数据行的一个被保存过的版本。换言之，读者和写者之间不会互相阻塞。写者之间还是会发生阻塞，而这也就是造成冲突的原因了。当冲突发生时，SQL. Server会生成一个错误消息，但这需要由上层的应用程序来响应此错误。</p>
</li>
</ol>
<p>简述来说就是：</p>
<ul>
<li>悲观模型：在悲观模型中，写者总是阻塞读者和写者，而读者也会阻塞写者。</li>
<li>乐观模型：在乐观模型中，唯一可能发生的阻塞是写者阻塞其他写者。</li>
</ul>
<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><h4 id="ACID属性"><a href="#ACID属性" class="headerlink" title="ACID属性"></a>ACID属性</h4><p>事务处理保证了SQLServer数据库的一致性( consisitency）以及可复原性( recoverability )。它保证了所有事务都是作为一个单独的任务单元被执行的——即使发生了硬件故障或者一般的系统故障。这样的事务被认为具有ACID属性:</p>
<ul>
<li><p>原子性(atomicity) </p>
<p>SQL Server保证事务的原子性。原子性指的是每个事务被视为全部或者什么也没有——不是提交(commit）就是中止 (abort)。如果一个事务提交了，它造成的所有效果都会被保留。如果中止了，其所有效果都会被撤销。</p>
</li>
<li><p>一致性(consistency)</p>
<p>一致性属性确保事务不允许系统到达一个不准确的逻辑状态——数据必须总是保持逻辑上的正确。即使在发生系统故障时，约束和规则也必须得到承兑。</p>
</li>
<li><p>隔离性(isolation）</p>
<p>隔离性会将并发事务与其他未完成（incomplete）事务的更新操作分隔开。</p>
<p>SQL Server会在事务之间自动实现隔离。它采用锁定数据或者新建行版本来使多个并发用户能够操作数据，以防止导致不正确结果的副作用发生，并且如果用户想要序列化他们的请求时（也就是将请求排队等候并且一次只处理一个的方式）使其与预期值不同。这个可序列化特性也是SQL Server 所支持的隔离级别中的一种。SQL Server支持多种隔离级别，因此用户能够在锁定多少数据和持有多长时间的锁之间进行适当权衡( tradeoff）并且选择是否允许用户访问以前版本的行数据。这种权衡也就是大家熟知的并发性 vs.一致性(concurrency vs. consistency)。</p>
</li>
<li><p>持久性(durability)</p>
<p>当事务提交以后，SQL Server 的持久性属性就会确保该事务的作用持续存在（即使发生系统故障）。如果在事务进行过程中发生了系统故障，事务就会被完全撤销，不会在数据上遗留部分作用。譬如说，</p>
<p>如果在事务的中间过程（事务提交之前)发生了停电，整个事务就被回滚（rollback）到系统重启时的状态。</p>
<p>如果在事务的提交确认被发送到调用的应用程序之后立刻发生了停电，数据库会确保该事务的存在。预写式日志( write-ahead logging）以及SQL Server启动恢复阶段（recovery phase)的事务自动回滚&#x2F;前滚机制能够确保持久性。</p>
</li>
</ul>
<p>除了保证显式多语句事务能够维持ACID属性以外，SQL Server还确保隐式事务同样维持ACID 属性。</p>
<p>用户对于隔离级别的选择决定了下列这些行为中哪种是被允许的：</p>
<ul>
<li><p>丢失更新(Lost updates)</p>
<p>丢失更新（Lost updates)当两个进程读取相同数据并且都处理该数据（修改它的值），然后都尝试更新原来的数据成新的值时，这种行为就会产生了。第二个进程可能完全覆盖掉第一个所完成的更新。</p>
</li>
<li><p>脏读(Dirty reads)</p>
<p>脏读(Dirty reads)这种行为在一个进程读取未提交数据时会产生。如果一个进程修改了数据但是尚未提交修改，而另一个正在读取数据的进程会读到这个修改从而导致-一种不一致的状态发生。</p>
<p>默认情况下，脏读是不允许的。谨记:更新数据的进程是无法控制别的进程在它提交之前读取其数据的。这是由读取数据的进程来决定是否想要读取未必会被提交的数据。</p>
</li>
<li><p>不可重复读(Non-repeatable reads)</p>
<p>不可重复读( Non-repeatable reads)这种行为又被叫做“不一致分析”( inconsistent analysis）。如果一个进程在同一事务中分别以两个读操作读取相同资源时可能会得到不同的值，这就是不可重复读。这种情况可能发生在第一个进程执行两次读操作的间隔内别的进程修改数据的时候。</p>
</li>
<li><p>幻影(Phantoms)</p>
<p>幻影(Phantoms)这种行为产生于一个数据集内的部分数据被修改时。这只发生在查询中带有一个谓词（ predicate )的时候——譬如WHERE count_of .widgets &lt; 10 这样的。如果在同一事务中使用相同谓词的两次SELECT操作返回不同数量的结果集，幻影就产生了。</p>
</li>
</ul>
<h4 id="隔离级别-ISOLATION-LEVEL"><a href="#隔离级别-ISOLATION-LEVEL" class="headerlink" title="隔离级别(ISOLATION LEVEL)"></a>隔离级别(ISOLATION LEVEL)</h4><ol>
<li><p>未提交读(UNCOMMITTED READ)：悲观模型</p>
<p>对于未提交读隔离级别来说，除了丢失更新以外，以上提到的所有行为都有可能发生。用户的查询可能读到未提交的数据，并且不可重复读以及幻影都是有可能存在的。<strong>未提交读是通过使读操作不占有任何锁来实现的，而且由于SQL Server 不再尝试获取锁，也就不会被其他进程所占有的相冲突的锁阻塞住了。</strong>用户的进程能够读取其他进程已经修改过但尚未提交的数据。尽管该模式通常并不是理想的选择，但是由于未提交读，用户就不会卡在等待锁上，并且读操作不占有任何锁而可能影响到其他正在读取或者写入数据的进程。</p>
<p>当采用未提交读时，用户是放弃了对于高一致性数据〈strongly consistent data）的把握而趋向于支持系统的高并发能力，使用户不会再互相锁定住对方。</p>
<p><strong>未提交读是针对阻塞太频繁问题的一种悲观的解决方案，因为它只是忽略了锁而不保障事务的一致性。</strong></p>
<p>简单来说就是：读操作不申请锁,运行读取未提交的修改,也就是允许读脏数据,读操作不会影响写操作请求排他锁.</p>
</li>
<li><p>已提交读(READ COMMITTED)：既支持乐观模型也支持悲观模型</p>
<p>这种隔离级别既可以是乐观的也可以是悲观的，取决于数据库的 READ_COMMTED_SNAPSHOT设置。因为这个数据库选项默认是关闭的，所以<strong>该隔离级别在默认情况下是采用悲观并发控制。</strong></p>
<p>当提到悲观实现时采用的是“已提交读（锁定）”，而对于乐观实现采用的则是“己提交读（快照）”。</p>
<p><strong>已提交读隔离级别保证了一个操作不会读到别的程序已经修改但尚未提交的数据。</strong>(也就是说，它决不会读到逻辑上根本未曾存在过的数据）对于已提交读（锁定〉，如果别的事务正在更新数据并因此在数据行上持有排他锁（exclusive locks），用户的事务就必须等待这些锁释放以后才能使用这个数据（无论是读取还是修改）。同样地，事务必须至少在要被访问的数据上加上共享锁(share locks)，这意味着该数据无法被其他人使用。共享锁不会妨碍其他人读取数据，但是它会使其他人需要等待才能更新数据。<strong>默认情况下，共享锁在数据处理过后就被释放了——它们无需在事务的持续时间内（甚至无需在语句的持续时间内）被保留</strong>（也就是说，如果获取了共享行锁，即使语句可能还需要处理更多行数据，每个行级锁可以在当前行被处理完毕以后马上释放掉）。<br>已提交读（快照）也能确保个操作不会读到未提交数据，但不是通过迫使其他进程等待的方式。对于已提交读（快照），每当一行数据被更新以后，SQL Server就会生成该行数据前一次已提交值的一个版本（ version）。被修改的数据仍旧被锁定着，但是其他进程可以看到该数据在更新操作开始之前的版本。</p>
<p>简单来讲就是：该隔离级别读操作之前首先申请并获得共享锁，允许其他读操作读取该锁定的数据，但是写操作必须等待锁释放，一般读操作读取完就会立刻释放共享锁。</p>
</li>
<li><p>可重复读(REPEATABLE READ)：悲观模型</p>
<p>可重复读是一种悲观的隔离级别。它在已提交读的基础上增加了新的属性:<strong>确保当事务重新访问数据或查询被再一次执行时数据将不再发生改变。</strong>换句话说，在一个事务中执行相同的查询两次是不会看到由其他用户的事务所造成的任何数据上的改变的。然而，可重复读隔离级别还是允许幻影行的出现。<br>在某些情况下，防止不可重复读是用户向往的一种安全措施。但是世上没自免费的午餐。这种额外的安全措施所带来的开销是<strong>事务中所有的共享锁必须保留到事务完成(COMMIT或者ROLLBACK）为止。</strong>(排他锁必须总是保留到事务结束为止，无论采用何种隔离级别或者并发模型，这样事务才能在需要时被回滚。如果锁较快就释放了，就不太可能完成撤销工作，因为其他并发事务有可能已经使用了同一数据，并且修改了它的值）。<strong>只要事务是打开的，没有其他用户可以修改被该事务所访问的数据。</strong>显然，这会严重降低并发性和性能。如果事务不保持简短或者如果编写应用程序时没有能够注意到这样潜在的锁竞争问题，当一个进程正在等待锁被释放时，SQL Server就会表现出“挂起”( hang）的状态。</p>
<p>简单来说就是：保证在一个事务中的两个读操作之间，其他的事务不能修改当前事务读取的数据，该级别事务获取数据前必须先获得共享锁同时获得的共享锁不立即释放一直保持共享锁至事务完成，所以此隔离级别查询完并提交事务很重要。</p>
</li>
<li><p>快照(SNAPSHOT)：乐观模型</p>
<p>快照隔离是一种乐观隔离级别。类似于已提交读（快照），如果当前版本被锁定住时，它允许进程读取已提交数据的早期版本。快照隔离和已提交读（快照）的区别与早期版本该有多早这个问题相关。尽管快照隔离所避兔的行为和可串行化所避免的是相同的，但是快照隔离并不是真正意义上的可串行化隔离级别。对于快照隔离，可能会有两个事务在同时执行，并引起一个在任何序列化执行中都不可能产生的结果。</p>
</li>
<li><p>可串行化(SERIALIZABLE)：悲观模型</p>
<p>可串行化也是一种悲观隔离级别。可串行化隔离级别在可重复读的基础上增加了新的属性:确保在重新执行查询时，SQL Server不会在中间的过渡时期（interim)增加新的行。换句话说，如果在同一事务中相同的查询被执行两次的话，幻影就不会出现了。可串行化也因此成为最健壮的悲观隔离级别，因为它防止了之前所述的所有可能的不合人意的行为——也就是说，它不允许未提交读、不可重复读和幻影，并且还保证了事务依次执行。</p>
<p>防止幻影是另一种合人所愿的安全措施。但是需要再次强调的是，天下是没有免费午餐的。这种额外的安全措施的开销与可重复读的差不多…—事务中的所有共享锁必须保留到事务完成为止。另外，执行可串行化隔离级别不仅需要锁定已读数据，还需要锁定那些不存在的数据!</p>
<p>简单来讲就是：可重复读能保证事务可重复读，但是事务只锁定查询第一次运行时获取的数据资源（数据行），而不能锁定查询结果之外的行，就是原本不存在于数据表中的数据。因此在一个事务中当第一个查询和第二个查询过程之间，有其他事务执行插入操作且插入数据满足第一次查询读取过滤的条件时，那么在第二次查询的结果中就会存在这些新插入的数据，使两次查询结果不一致，这种读操作称之为幻读。为了避免幻读需要将隔离级别设置为SERIALIZABLE</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
<th>并发控制模型</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>悲观</td>
</tr>
<tr>
<td>已提交读</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>悲观</td>
</tr>
<tr>
<td>已提交读(快照)</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>乐观</td>
</tr>
<tr>
<td>可重复读</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>悲观</td>
</tr>
<tr>
<td>快照</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>乐观</td>
</tr>
<tr>
<td>可串行化</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>悲观</td>
</tr>
</tbody></table>
<p>查看当前数据库事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DBCC USEROPTIONS </span><br></pre></td></tr></table></figure>

<p>设置并发控制方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL <span class="operator">&lt;</span>ISOLATION NAME<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="锁-Locking"><a href="#锁-Locking" class="headerlink" title="锁-Locking"></a>锁-Locking</h3><p>SQL Server 提供两种独立的锁定体系。</p>
<p>第一种体系影响所有完全共享的数据并提供行级锁、分页锁、表、数据分页、LOB分页以及索引分页叶级别上的表级锁。</p>
<p>第二种体系是SQL Server 内部使用的，用来处理索引并发控制，管理对于内部数据结构的访问以及获取数据分页中的个别记录。第二种系统采用了闩(shuan)(latch)，比锁要少耗资源并能提供性能优化。</p>
<p>锁和门之间的区别是：锁保证数据的逻辑一致性，而闩则保证物理一致性。当用户将一行记录物理地放置到一个分页上或者通过其他方式来移动数据（譬如在一个分页上压缩空间)。闩锁(latching〉就会发生了。SQL Server必须保证这类数据移动能够不受干扰地发生。</p>
<h4 id="锁的模式"><a href="#锁的模式" class="headerlink" title="锁的模式"></a>锁的模式</h4><p>锁的模式：共享锁、排它锁、更新锁、意向锁以及这些类型的一些变种。</p>
<ol>
<li><p>共享锁(Shared Locks)</p>
<p>当数据被读取时，SQL Server自动获取共享锁。共享锁可以被一张表、一个分页、一个索引键或者一个单独的行所持有。许多进程可以在同-数据上都持有共享锁，但是没有进程可以在已经有一个共享锁存在的情况下，在该数据上再获得一个排他锁（除非申请排他锁的进程和持有共享锁的进程是同一个）。<strong>一般地，当数据已经读取完毕后，共享锁就会立即释放掉</strong>，但是可以通过使用查询提示(query hints）或者采用不同的事务隔离级别来改变这种（默认）方式。</p>
</li>
<li><p>排它锁(Exclusive Locks)</p>
<p>当数据被插入、更新或者删除操作修改以后，SQL Server就会自动获取数据上的排他锁。一次只能有一个进程持有特定数据资源上的排他锁。实际上，如果别的进程已经排他性地锁定住某个进程所要申请的数据资源，那么该进程就无法获取任何类型的锁了。排他锁会保留到事务结束为止。这就意味着被修改的数据通常在当前事务提交或者回滚之前对其他进程来说是不可用的。<strong>其他进程可以通过使用查询提示来读取被排他性锁定的数据。</strong>如使用(NoLock)脏读。</p>
</li>
<li><p>更新锁(Update Locks)</p>
<p>更新锁实际上并不是一种独立的锁，它们是共享锁和排他锁的一种混合（hybrid)。当SQL Server执行一个数据修改操作但首先需要搜索表以寻找到要被修改的资源时,更新锁就会被获取了。通过使用查询提示，一个进程可以明确地申请更新锁，在这种情况下，更新锁就能够预防转换死锁(conversion deadlock)的情况。<br>更新锁提供对当前其他数据读者的兼容性，在确保数据自上次读取以后尚未修改的前提下，使进程能够在稍后对数据进行修改。更新锁本身是不足以使用户能够修改数据的——<strong>所有的数据修改都要求被修改的数据资源上存在一个排他锁。</strong>更新锁的作用就好像一个串行化闸门（serialization gate），将后续申请排他锁的请求压入队列中（许多进程都可以对一个资源持有共享锁，但是只有几个进程能够持有更新锁)。<strong>只要有一个进程对资源持有更新锁，其他进程就无法获取该资源的更新锁或者排他锁了，而其他正在申请相同资源上更新锁或者排他锁的进程就必须等待了。</strong>持有更新锁的进程能够将其转换成该资源上的排他锁，因为更新锁避免了与其他进程之间的锁不兼容性。<strong>可以将更新锁看作是“意图更新”(intent-to-update）锁，在根本上也就是它们所扮演的角色了。</strong>如果单独使用的话，更新锁是不足以更新数据的—-仍然需要获取排他锁来进行实际的数据修改。对于排他锁的依次访问可以避免转换死锁(conversion deadlock）的发生。更新锁会保留到事务结束或者当它们转换成排他锁时为止。<br>不要被名字所误导了：更新锁并不只是针对更新操作而设计的。<strong>SQL Server使用更新锁适用于任何需要在进行实际修改之前搜索数据的数据修改操作。</strong>这样的操作包括受限更新及删除，也包括在带有聚集索引的表上进行的插入操作。对于后面一种情况，SQLServer必须先搜索数据（使用聚集索引）以找到正确的位置来插入新的记录。<strong>当 SQLServer 只进行到搜索阶段时，它会采用更新锁来保护数据，而只有当它找到正确的位置并开始插入以后才将更新锁升级成排他锁。</strong></p>
</li>
<li><p>意向锁(Intent Locks)</p>
<p>意向锁实际上并不是一种独立的锁定模式，它们是之前讨论过的那些模式的限定词(qualifier)。换句话说，可以拥有意向共享锁、意向排他锁甚至意向更新锁。<strong>由于SQLServer 可以在不同级别的粒度上获取锁，因此需要一种机制来指出一个资源上的组件已经被锁定住了。</strong>举例来说，如果一个进程试图锁定一张表，SQL Server就需要采用一种方式来判断这张表上的一行（或者一个分页)已经被锁定住了。意向锁就是起这个作用的。</p>
</li>
<li><p>架构稳定锁( schema stability locks) </p>
<p>当查询被编译时，架构稳定锁会防止其他进程获取架构修改锁（在表结构被修改时获得〉。</p>
</li>
<li><p>架构修改锁( schema modification locks）</p>
</li>
<li><p>大容量更新锁(（bulk update locks)。</p>
<p>在执行BULK INSERT命令或者使用bep工具将数据导入表时就会获取大容量更新锁。另外，大容量导入操作必须使用TABLOCK查询提示来请求这个特殊的锁。或者，可以将表的table lock on bulk load选项设为true，然后任何大容量导入(bulk copy IN)或者BULK INSERT操作都会自动申请大容量更新锁。申请这种特殊的大容量更新表级锁不一定代表会授予(grant）这个锁。如果其他进程已经持有了表上的锁，或者表上有索引存在，就不会授予大容量更新锁了。如果有多个连接已经申请并得到了一个大容量更新锁，它们可以执行并行调用将数据导入相同的表中。与排他锁不同的是，大容量更新锁之间不会互相冲突，因此多连接的并发插入在 SQL Server中是支持的。</p>
</li>
<li><p>转换锁(Converion Locks)</p>
<p>SQL Server不会直接申请转换锁,而是由一种模式转换成另一种模式所造成的。SQLScrver 2005所支持的三类转换锁是:SIX、SIU 以及UIX。其中最常见的是SIX，如果事务正持有一个资源上的共享锁(S）并在稍后需要一个意象排他(IX)锁时产生，这种锁定模式可以简写为 SIX。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>缩写</th>
<th>锁定模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>Shared</td>
<td>允许其他用户读取但不能修改被锁定资源</td>
</tr>
<tr>
<td>X</td>
<td>Exclusive</td>
<td>防止别的进程修改或者读取被锁定资源的数据(除非该进程设定为未提交读隔离级别)</td>
</tr>
<tr>
<td>U</td>
<td>Update</td>
<td>防止其他进程获取更新锁或者排他锁：在搜索数据并修改时使用</td>
</tr>
<tr>
<td>IS</td>
<td>Intent Shared</td>
<td>表示该资源的一个组件被一个共享锁锁定住了。这类锁只能在表级或者分页级才能被获取</td>
</tr>
<tr>
<td>IU</td>
<td>Intent Update</td>
<td>表示该资源的一个组件被一个更新锁锁定住了。这类锁只能在表级或者分页级才能被获取</td>
</tr>
<tr>
<td>IX</td>
<td>Intent Exclusive</td>
<td>表示该资源的一个组件被一个排他锁锁定住了。这类锁只能在表级或者分页级才能被获取</td>
</tr>
<tr>
<td>SIX</td>
<td>Shared With Intent Exclusive</td>
<td>表示一个正持有共享锁的资源还有一个组件(一个分页或者一行记录)被一个排他锁锁定住了</td>
</tr>
<tr>
<td>SIU</td>
<td>Shared With Intent Update</td>
<td>表示一个正持有共享锁的资源还有一个组件（一个分页或者一行记录〉被一个更新锁锁定住了</td>
</tr>
<tr>
<td>UIX</td>
<td>Update With Intent Exclusive</td>
<td>表示-个正持有更新锁的资源还有一个组件(一个分页或者行记录)被一个排他锁锁定住了</td>
</tr>
<tr>
<td>Sch-S</td>
<td>Schema Stability</td>
<td>表示一个使用该表的查询正在被编译</td>
</tr>
<tr>
<td>Sch-M</td>
<td>Schema Modification</td>
<td>表示表的结构正在被修改</td>
</tr>
<tr>
<td>BU</td>
<td>Bulk Update</td>
<td>在一个大容量复制操作将数据导入表并且应用了TABLOCK查询提示时使用(手动或者自动皆可)</td>
</tr>
</tbody></table>
<h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>锁的粒度：规定了一个单独的锁能够覆盖多少数据。可以是一行、一个分页、一个索引键、索引键的一个范围、一个扩展抑或是整张表。</p>
<p>SQL Server可以锁定表、分页、行等级别的用户数据资源〈非系统资源;而系统资源是由闩来保护的）。它同样可以锁定索引键以及一定范围内的索引键。<strong>谨记如果表上存在聚集索引，数据行就在聚集索引的叶级别并且是由键锁而不是行锁来锁定它们的。</strong></p>
<p>sys.dm_tran_locks视图对每个锁都进行追踪并且包含了被锁定资源（譬如行、键或者分页)、锁的模式以及特定资源的一个标识符（identifier)。<strong>谨记: sys.dm_tran_locks 只是一个用来显示所持有锁的动态管理视图。实际的信息是储存在SQL Server 内部的数据结构中，对用户来说是完全不可见的。</strong>因此，当谈论到sys.dm_tran_locks 视图中所存在的信息时，实际上指的就是通过该视图能够看到的信息。<br>当一个进程申请锁时，SQL Server会将所申请的锁与sys.dm_tran_locks中已经列出的资源相比较并寻找完全匹配资源类型（resource_type）以及标识符（identifier）的锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 有时候我们只需关注加在数据资源上的锁</span></span><br><span class="line"><span class="keyword">SELECT</span> resource_type,resource_description,</span><br><span class="line">resource_associated_entity_id,request_mode,request_status</span><br><span class="line"><span class="keyword">FROM</span> sys.dm_tran_locks</span><br><span class="line"><span class="keyword">wHERE</span> resource_associated_entity_id <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--sys.dm_tran_locks是一个用来显示所持有锁的动态管理视图</span></span><br><span class="line"><span class="keyword">select</span>    </span><br><span class="line">    request_session_id spid,   </span><br><span class="line">    OBJECT_NAME(resource_associated_entity_id) tableName    </span><br><span class="line"><span class="keyword">from</span>    </span><br><span class="line">    sys.dm_tran_locks   </span><br><span class="line"><span class="keyword">where</span>    </span><br><span class="line">    resource_type<span class="operator">=</span><span class="string">&#x27;OBJECT&#x27;</span>  </span><br></pre></td></tr></table></figure>

<h5 id="键锁"><a href="#键锁" class="headerlink" title="键锁"></a>键锁</h5><p>SQL Server 2005支持两种类型的键锁，而它究竞采用哪种类型则取决于当前事务的隔离级别。如果隔离级别是已提交读、可重复读或者快照，SQL Server会在处理查询时尝试锁定实际被访问的索引键。对于拥有聚集索引的表而言，数据行就是索引的叶级别,而用户可以看到所获得的键锁。如果表是堆结构(heap）的话，用户可能会看到非聚集索引上的键锁以及实际数据上的行锁。<br>如果隔离级别是可串行化，情况就有所不同了。为了防止幻影，如果在一个事务中扫描了一个范围内的数据就需要充分锁定住该表以确保没人能够插入新值到已扫描的范围内。</p>
<h5 id="应用程序级锁"><a href="#应用程序级锁" class="headerlink" title="应用程序级锁"></a>应用程序级锁</h5><p>SQL Server储存锁定信息及检查不兼容锁所采用的方法是相当直观和可扩展的。SQL Server并不知道被它锁定的对象。它仅仅是处理一-些代表资源的字符串，并不知道该对象的实际结构。如果两个进程试图在同一资源上获取不相兼容的锁就会发生阻塞。<br>应用程序级锁使用户能够利用SQL Server提供的检测阻塞和死锁情况的机制，并且可以选择锁定住任何想要锁住的东西。这些可锁定资源就是应用程序级锁。要定义一个应用程序级锁，就要为想要锁定的资源指定一个名字、锁的模式、所有者(或者范畴)、超时设定以及<strong>一个数据库主体ID(Database Principal lD，也就是数据库中能够拥有权限的一个用户、角色、应用程序角色等）</strong>。与SQL Server自己的可锁定资源（如表和分页等）不同的是，应用程序级锁必须进行明确地申请。只有符合以下标准之一的用户才能够执行sp _getapplock存储过程:</p>
<ul>
<li>用户(user）是dbo</li>
<li>用户属于db_owner角色</li>
<li>用户属于指定的数据库主体ID角色（如果ID是一个个体的名字）</li>
<li>用户属于指定的数据库主体ID角色(如果ID是一个角色）</li>
</ul>
<p>默认的数据厍主体ID是public(可以调用sp _getapplock察看）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Param1:锁定资源别名,不超过255个字符</span></span><br><span class="line"><span class="comment">-- Param2:锁的模式可以是共享/排他/更新/意向排他/意向共享锁等,下面是一个排他锁</span></span><br><span class="line"><span class="comment">-- Param3:锁的范围可以是事务或会话,下面是一个会话</span></span><br><span class="line"><span class="comment">-- Param4:数据库主体ID</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_getapp1ock <span class="string">&#x27;ProcLock &#x27;</span>，<span class="string">&#x27;Exclusive&#x27;</span>，<span class="string">&#x27;session&#x27;</span>，<span class="string">&#x27; ProcUserRole&#x27;</span></span><br><span class="line"><span class="keyword">EXEC</span> MyProc <span class="operator">&lt;</span><span class="keyword">parameter</span> <span class="number">1</span>ist<span class="operator">&gt;</span></span><br><span class="line"><span class="comment">-- 存储过程执行完毕以后释放锁</span></span><br><span class="line"><span class="keyword">EXEC</span> sp_releaseapplock <span class="string">&#x27;ProcLock &quot; , &#x27;</span>session<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>SQL Server只是在申请应用程序锁时往sys.dm_tran_locks 视图中添加一行记录，并且通过资源名称和数据库主体ID来与其他已经申请过的锁进行比较。</strong>注意存储过程本身实际上并没有被锁定住。如果别的用户或应用程序不知道这是一个特殊的存储过程，并且试图不通过获取应用程序锁来执行MyProc，SQL Server并不会阻止该会话执行这个存储过程。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建锁表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [dbo].[Sys_Lock]</span><br><span class="line">(</span><br><span class="line">[LockName] [nvarchar] (<span class="number">50</span>) ,</span><br><span class="line">[LockStatus] [bit]</span><br><span class="line">) <span class="keyword">ON</span> [<span class="keyword">PRIMARY</span>]</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建事务后更新Sys_Lock生成一个更新锁</span></span><br><span class="line"><span class="keyword">Update</span> Sys_Lock <span class="keyword">Set</span> LockStatus<span class="operator">=</span><span class="number">1</span> <span class="keyword">Where</span> LockName<span class="operator">=</span><span class="string">&#x27;Lock&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="鉴别锁定资源"><a href="#鉴别锁定资源" class="headerlink" title="鉴别锁定资源"></a>鉴别锁定资源</h5><p>当SQL Server要决定是否可以授予一个申请的锁时,会检查sys.dm _tran_locks 视图来判断是否已经有处于冲突锁模式的匹配锁存在了。它通过察看数据库ID(resource_database_ID) 、resource_description . resource_associated_entity _.id字段中的值以及被锁定资源的类型来比较锁。SQL Server并不了解资源描述中的含义。它只是比较识别锁资源的字段来寻找一个匹配。如果发现一个匹配且request _status值是GRANT，它就知道资源已经被锁定住了。然后SQL Scrver 会利用锁兼容性矩阵来判断当前的锁是否在正申请的锁中兼容。</p>
<table>
<thead>
<tr>
<th>资源类型</th>
<th>资源描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>DATABASE</td>
<td>无：每个被锁资源的resource_database_ID字段都指明了数据库</td>
<td></td>
</tr>
<tr>
<td>OBJECT</td>
<td>对象ID(可以是任何数据库对象,不一定就是表)其数值是由resource_associated_entity_id字段反馈的</td>
<td>69575286</td>
</tr>
<tr>
<td>EXTENT</td>
<td>扩展的第一个分页的文件号:页号</td>
<td>1:96</td>
</tr>
<tr>
<td>PAGE</td>
<td>实际表或者索引分页的文件号:分页号</td>
<td>1:104</td>
</tr>
<tr>
<td>KEY</td>
<td>由所有键的组成部分及定位符得到的哈希值。对于一个建在堆上的非聚集索引(c1和c2是索引列),哈希将包含来自c1,c2以及RID的贡献</td>
<td>ac0001a10a00</td>
</tr>
<tr>
<td>ROW</td>
<td>实际数据行的文件号:页号:槽号</td>
<td>1:161:3</td>
</tr>
<tr>
<td>APPLICATION</td>
<td>一个连接串,由以下几个部分组成:有权访问该锁的数据库主体、锁名的前32个字符以及根据该锁全名得到的哈希值</td>
<td>0:[ProcLock]:(8e14701f)</td>
</tr>
</tbody></table>
<p>注意:键锁和键范围锁具有相同的资源描述，因为键范围被视为一种锁定模式，而不是一种锁定资源。当察看sys.dm_tran_locks 视图的输出结果时，可以通过锁模式字段的值来区分各种类型的锁。</p>
<p>对于一个较大实体内的部分被锁资源，sys.dm_tran_locks中的resource_associated.entity_id字段显示了数据库中的那个关联实体的ID。</p>
<h4 id="锁的持续时间"><a href="#锁的持续时间" class="headerlink" title="锁的持续时间"></a>锁的持续时间</h4><p>锁的持续时间：一些锁在数据被访问完成以后会立刻释放掉，有些锁会保留到事务提交或回滚为止。</p>
<p>锁的持续时间主要取决于锁的模式和当前作用的事务隔离级别。<strong>SQLServer的默认隔离级别是已提交读。在该级别下，SQL Server会在读取和处理完锁定数据以后立刻释放共享锁</strong>。对于快照隔离级别，其行为也是相同的——SQL Server 读完数据后立即释放共享锁。如果事务隔离级别是可重复读或者可串行化，共享锁就和排他锁的持续时间相同。也就是说，直到事务结束时才会被释放。对于任何隔离级别，无论事务是被提交还是被回滚，排他锁都会一直持续到事务结束为止。更新锁也会像排他锁一样总是持续到事务结束，除非它已经被升级成排他锁了（在这种情况下的排他锁，其实对于排他锁来说总会保留到事务结束为止）。</p>
<p>除了改变事务隔离级别，还可以使用查询提示来控制锁的持续时间。</p>
<h4 id="锁的所有权问题"><a href="#锁的所有权问题" class="headerlink" title="锁的所有权问题"></a>锁的所有权问题</h4><p>锁的所有权问题：锁可以被一个会话、事务或者游标所拥有。</p>
<p>一共存在四种锁的所有者(或范畴）类型:事务型、游标型、事务工作空间型(transaction_workspace)和会话型。可以通过.sys.dm_tran_locks视图的request_owner_type字段来察看锁的所有者。</p>
<h4 id="观察锁"><a href="#观察锁" class="headerlink" title="观察锁"></a>观察锁</h4><p>sys.dm_tran_locks中的所有字段名都是以两种前缀中的一种来开头的。以 resource_开头的字段对SQL Server正在其上申请锁的这个资源进行了描述。以request_开头的字段描述了中请过程。只有当所有的resource_字段内容相同时，才表示两个申请作用于相同的资源上。</p>
<h5 id="请求字段"><a href="#请求字段" class="headerlink" title="请求字段"></a>请求字段</h5><p>请求字段之前也已提到了几个sys.dm_tran_locks 中最重要的request_字段，</p>
<ul>
<li>request_mode (申请锁的类型) </li>
<li>request_owner_type(申请锁的范畴）</li>
<li>request_type：sys.dm_tran_locks中追踪的唯一资源申请类型是锁(LOCK）</li>
<li>request _status：请求的当前状态可以是以下三个值中的一个:GRANT、CONVERT或者WAIT。<ul>
<li>CONVERT状态表示请求者已经被授予了相同资源上的一个不同模式的请求，所以当前正处于从所要授予的锁定模式进行升级（转换）的等待状态中（譬如，SQL Server可以将一个U锁转换成X锁）</li>
<li>WAIT状态表示请求者当前还未在资源上持有一个已授权的请求</li>
</ul>
</li>
<li>request_reference_count：该值返回同意请求程序已请求该资源的近似次数，并且仅适用于那些在事务结束时不会自动释放的资源。如果该值递减到0并且request_lifetime也是0的话，一个已授权资源就不再被视作被某个请求者占有着了。</li>
<li>request_lifetime：该值表示资源上的锁何时会释放。</li>
<li>request_session_id：该值表示当前拥有该请求的会话ID。对于分布式事务(DTC）和绑定事务，拥有请求的会话ID可能不同。该值为-2时，指示该请求属于孤立的分布式事务。该值为-3时，指示请求属于延迟的恢复事务(例如因其回滚未能成功完成而延迟恢复该回滚的事务）。</li>
<li>request_exec_context_id：该值表示当前拥有该请求的进程的执行上下文ID。如果该值大于0，表示这是一个用于执行并行查询的子线程。</li>
<li>request_request_id：该值是当前拥有该请求的进程的请求ID(批处理ID)。SQLServer只有在来自多个活动的结果集（MARS）的客户端应用程序的请求的情况下才会填充这个字段。</li>
<li>request_owner_id：该值目前仅供所有者为事务的请求使用，且所有者ID就是事务ID。该字段可以与sys.dm_tran_active_transactions视图中的transaction_id字段进行连接。</li>
<li>request_owner_guid：该值目前仅供分布式事务使用，在该事务中，该值与事务的DTC GUID相对应。</li>
<li>lock_owner_address：该值用于跟踪该请求的内部数据结构的内存地址。如果请求处于WAIT或者CONVERT 状态,该字段可以与sys.dm_os_waiting_tasks中的resource_address字段连接。</li>
</ul>
<p>参考：</p>
<ul>
<li>Microsoft SQL Server 2005技术内幕：存储引擎</li>
<li>Microsoft SQL Server 2005技术内幕：T-SQL程序设计</li>
<li>Microsoft SQL Server 2005技术内幕：查询、调整和优化</li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>ReadingNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>What&#39;s UOW?</title>
    <url>/2023/09/08/What&#39;s%20UOW/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="What’s-UOW"><a href="#What’s-UOW" class="headerlink" title="What’s UOW?"></a>What’s UOW?</h2><p>“A Unit of Work keeps track of everything you do during a business transaction that can affect the database. When you’re done, it figures out everything that needs to be done to alter the database as a result of your work.”   – Martin Fowler</p>
<p>SO Unit of Work Key Info:</p>
<ul>
<li>UOW keeps track of changes</li>
<li>UOW maintenance change list</li>
<li>UOW commits all changes at once</li>
</ul>
<p>EF Core DbContext naturally UOW is realized</p>
<ul>
<li><p>Each DbContext instance has a ChangeTracker that tracks changes to the entity</p>
</li>
<li><p>When DbContext.SaveChanges is called, all changes are committed to the database in one go via the transaction</p>
</li>
</ul>
<p><strong>Implementing Repository pattern in domain-driven Design，By UOW UnitOfWorkInterceptor took over after ApplicationServervice methods performed DbContext. SaveChanges operation</strong></p>
<p><strong>The transaction is just a way to realize the unit of work. EFCore can implement UOW without using transactions.</strong></p>
<h2 id="What’s-Ambient-Transactions"><a href="#What’s-Ambient-Transactions" class="headerlink" title="What’s Ambient Transactions?"></a>What’s Ambient Transactions?</h2><p><strong>Common Transaction：</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> ApplicationDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> transaction = context.Database.BeginTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        student1.Name = <span class="string">&quot;Robert Fatou&quot;</span>;</span><br><span class="line">        context.Add(student1);</span><br><span class="line">        context.SaveChanges();</span><br><span class="line">        <span class="comment">// The Id will have a valid value</span></span><br><span class="line">        Console.WriteLine(student1.Id);</span><br><span class="line">        <span class="comment">// Let&#x27;s revert the operation</span></span><br><span class="line">        transaction.Rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Ambient Transaction：</strong></p>
<p>An <strong>ambient transaction</strong> is one that works at the thread level. Thus, all operations that occur in that context will be part of the transaction.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> scope = <span class="keyword">new</span> TransactionScope())</span><br><span class="line">    &#123;</span><br><span class="line">        CreateStudent();</span><br><span class="line">        CreateCourse();</span><br><span class="line">        <span class="comment">// Uncomment the following line if you want to</span></span><br><span class="line">        <span class="comment">// have the previous operations persisted in the Database</span></span><br><span class="line">        <span class="comment">//scope.Complete();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateCourse</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> ApplicationDbContext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> course = <span class="keyword">new</span> Course();</span><br><span class="line">        course.Name = <span class="string">&quot;Programming I&quot;</span>;</span><br><span class="line">        context.Add(course);</span><br><span class="line">        context.SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateStudent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> context = <span class="keyword">new</span> ApplicationDbContext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        student1.Name = <span class="string">&quot;Transaction Scope&quot;</span>;</span><br><span class="line">        context.Add(student1);</span><br><span class="line">        context.SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Reference：</strong></p>
<p><a href="https://www.martinfowler.com/eaaCatalog/unitOfWork.html">P of EAA: Unit of Work (martinfowler.com)</a></p>
<p><a href="https://learn.microsoft.com/en-us/ef/core/dbcontext-configuration/">DbContext Lifetime, Configuration, and Initialization - EF Core | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/en-us/ef/core/saving/transactions#cross-context-transaction">Transactions - EF Core | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/en-us/dotnet/framework/data/transactions/implementing-an-implicit-transaction-using-transaction-scope">Implementing an Implicit Transaction using Transaction Scope - .NET Framework | Microsoft Learn</a></p>
<p><a href="https://gavilan.blog/2018/08/02/entity-framework-core-2-1-ambient-transactions-new-functionality">Entity Framework Core 2.1: Ambient Transactions</a></p>
]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Pattern</tag>
      </tags>
  </entry>
</search>
